---
title: 浅析C#类型系统模块
date: 2022-06-30 23:05:52
link: understand-csharp-data-type-system
tags: c#-data-operate
categories: C#
---
> 本文主要围绕C#语言来举例描述、但游戏开发也涉及Lua，所以其中会拿Lua来比较，引申。
> 

C# 是一种强类型语言。 每个变量和常量都有一个类型，每个求值的表达式也是如此。编译器使用类型信息来确保在代码中执行的所有操作都是类型安全的。 例如，如果声明 `int` 类型的变量，那么编译器允许在加法和减法运算中使用此变量。 如果尝试对 `bool` 类型的变量执行这些相同操作，则编译器将生成错误。

除内置类型外，可以使用 `struct`、`class`、`interface`、`enum` 和 `record` 构造来创建自己的自定义类型。

CTS中的每种类型被定义为值类型或引用类型。 这些类型包括.NET 类库中的所有自定义类型以及你自己的用户定义类型。 使用 `struct` 关键字定义的类型是值类型；所有内置数值类型都是 `structs`。 使用 `class` 或 `record` 关键字定义的类型是引用类型。引用类型和值类型遵循不同的编译时规则和运行时行为。

- 类是引用类型。 创建类型的对象后，向其分配对象的变量仅保留对相应内存的引用。 将对象引用分配给新变量后，新变量会引用原始对象。 通过一个变量所做的更改将反映在另一个变量中，因为它们引用相同的数据。
- 结构是值类型。 创建结构时，向其分配结构的变量保留结构的实际数据。 将结构分配给新变量时，会复制结构。 因此，新变量和原始变量包含相同数据的副本（共两个）。 对一个副本所做的更改不会影响另一个副本。

![data-type](/images/202206/understand-csharp-1.webp)

## 一、什么是值类型和引用类型

值类型（Value Types）和引用类型（Reference Types）是两种常见的数据类型分类，它们在内存中的存储和使用方式有所不同。

1. 值类型（Value Types）：
    - 值类型的实例直接存储其实际的值，而不是对该值的引用(内存地址)；当将一个值类型赋值给另一个变量或作为参数传递时，将复制该值。
    - 值类型的赋值和操作是基于复制的，每个变量都有自己的独立值。
    - 值类型的存储通常发生在栈上，存储在变量的声明作用域内。
    - 值类型包括整数类型(byte/sbyte/short/ushort/int/uint/long/ulong)、浮点数类型(float/double)、字符类型(char)、布尔类型(bool)、枚举类型(enum)、结构体(struct)等。
2. 引用类型（Reference Types）：
    - 引用类型的实例存储在堆上；变量存储的是对该实例的引用(内存地址)，而不是实际的值；多个变量可以引用同一个对象。
    - 引用类型的赋值和操作是基于引用的，多个变量引用同一个对象，对对象的修改会影响所有引用它的变量。
    - 引用类型的存储通常发生在堆上，需要通过垃圾回收器来管理内存。
    - 引用类型包括类类型(class)、接口类型(interface)、委托类型(delegate)、字符串类型(string)等。

### 1.1 他们的主要区别是什么？

- 值类型存储实际值本身，而引用类型存储对对象的引用(内存地址)。
- 值类型的复制是值的复制，每个变量拥有独立的值，而引用类型的复制是引用的复制，多个变量引用同一个对象。
- 值类型存储在栈上，变量的生命周期与其作用域相对应，而引用类型存储在堆上，由垃圾回收器管理内存。
- 对值类型的操作是基于值的，而对引用类型的操作是基于引用(内存地址)的。
- 值类型的变量通常存储在栈上；而引用类型的对象存储在堆上，而变量本身存储在栈上，用于存储对象的引用。
- 赋值或传递值类型的变量时，会复制变量的值。而赋值或传递引用类型的变量时，会复制对象的引用，指向同一对象。
- 值类型的变量在声明时会有一个默认值，如 int 类型的默认值为 0。而引用类型的变量在声明时默认为 null，表示未引用任何对象。
- 值类型不支持继承和多态，因为它们是按值存储的。而引用类型可以通过继承和多态实现面向对象的特性。

需要注意的是，C# 中的某些引用类型具有值语义，如字符串类型(string)和结构体(struct)。这些类型在某些方面类似于引用类型，但也具有值类型的特征，如字符串的不可变性和结构体的值复制。例如在结构体中包含引用类型变量，通过实例化的复制后，两份结构体中的引用变量指向的是同一个引用地址(内存地址)。

### 1.2 lua中有类似C#之类值类型、引用类型的概念吗

在 Lua 中，所有的数据都是以值的形式存在，而不区分值类型和引用类型。Lua 中的值可以直接存储在变量中，或者通过引用传递。不过，Lua 中的 table 类型可以用于模拟字典、数组等数据结构，但它并不是引用类型，而是一种通用的数据容器。Lua中，变量的赋值和传递都是基于值的拷贝，而不是引用。当一个变量赋值给另一个变量时，会将变量的值复制一份。如果复制的是一个 table 类型的值，那么实际上是复制了 table 的引用，而不是拷贝整个 table。

即Lua中，不需要像 C# 中那样显式区分值类型和引用类型，而是直接处理变量的值。这也意味着在函数传参或赋值操作时，不会产生类似值类型和引用类型的语义和性能消耗。

## 二、类型转换过程中的装箱、拆箱

装箱是将值类型转换为 `object` 类型或由此值类型实现的任何接口类型的过程。 常见语言运行时 (CLR) 对值类型进行装箱时，会将值包装在 System.Object 实例中并将其存储在托管堆中。 取消装箱将从对象中提取值类型。装箱是隐式的；取消装箱是显式的。

![boxing-and-unboxing](/images/202206/understand-csharp-2.webp)

```csharp
//装箱
int i = 123;
object o = (object)i;  // explicit boxing

//拆箱
int i = 123;      // a value type
object o = i;     // boxing
int j = (int)o;   // unboxing
```

在 C# 中，装箱（Boxing）和拆箱（Unboxing）是值类型（Value Type）和引用类型（Reference Type）之间的相互转换操作。

1. 装箱（Boxing）：将值类型转换为引用类型的过程
    - 当值类型需要被赋值给一个 Object 类型的变量，或者作为参数传递给接受 Object 类型参数的方法时，会发生装箱操作。
    - 装箱操作会创建一个引用类型的对象，并将值类型的值复制到该对象中。装箱后，该值类型就被封装在引用类型对象中，可以按引用方式操作。
2. 拆箱（Unboxing）：将装箱后的引用类型转换为值类型的过程
    - 当需要从装箱后的引用类型中获取值类型的值，或者将其赋值给值类型变量时，会发生拆箱操作。
    - 拆箱操作将引用类型对象中封装的值类型数据提取出来，并将其赋值给值类型变量。

装箱和拆箱操作涉及将数据从值类型复制到引用类型对象中以及从引用类型对象中提取数据的过程。这些操作会涉及数据复制和内存分配，因此在性能上相对较低效。

### 2.1 如何避免不必要的装箱拆箱操作？

1. 使用泛型：
    - 在需要存储值类型的集合中，尽量使用泛型集合（如 **`List<T>`**、**`Dictionary<TKey, TValue>`**）而不是非泛型集合（如 **`ArrayList`**、**`Hashtable`**）。泛型集合在存储值类型时不会触发装箱操作。
    - 在定义接口或方法时，尽量使用泛型类型参数，以便处理值类型和引用类型的数据，避免在接口或方法中进行装箱和拆箱。
2. 对于需要在值类型中表示空值的情况，可以使用值类型的可空类型（如 **`int?`**、**`bool?`**），而不是将值类型装箱为引用类型（如 **`Nullable<int>`**）。可空类型不会触发装箱操作。
3. 某些API提供了直接操作值类型的方法，如 **`BitConverter`** 类用于将基本数据类型直接转换为字节数组，而不需要装箱操作。
4. 避免将值类型直接赋值给Object类型变量，尽量使用值类型的具体类型或泛型类型参数进行操作。
5. 使用装箱拆箱优化技术，如缓存装箱对象、使用对象池等，可以减少装箱和拆箱操作的频率，提高性能。

## 三、深浅拷贝操作

深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在进行对象复制时使用的两种不同的拷贝方式。

- 浅拷贝(Shallow Copy)：是指创建一个新对象，将原始对象的成员变量的值复制到新对象中。对于引用类型的成员变量，浅拷贝只复制引用而不复制引用指向的对象本身。因此，新对象和原始对象将共享相同的引用对象，对引用对象的修改会影响到新对象和原始对象。
- 深拷贝(Deep Copy)：是指创建一个新对象，并将原始对象的所有成员变量的值复制到新对象中，包括引用类型的成员变量。对于引用类型的成员变量，深拷贝会递归地复制引用指向的对象本身，而不仅仅是复制引用。因此，新对象和原始对象拥有独立的、完全相同的数据副本，对任一对象的修改都不会影响另一个对象。

浅拷贝适用于对象较简单、不包含引用类型成员或共享引用对象值的情况。而深拷贝适用于对象较复杂、包含引用类型成员且需要独立拷贝引用对象的情况。

一般情况下，默认是浅拷贝，而深拷贝则需要显式地操作或者通过特定的语言机制来实现。

深浅拷贝操作带来最大的好处就是保证了数据的独立性，避免共享数据和不受影响的修改操作。

在lua中，我们可以通过一些技巧实现深浅拷贝的操作；对于浅拷贝可以通过`table`来实现，当将一个表赋值给另一个变量时，实际上是将表的引用复制给了新变量。这样，新变量和原变量指向同一个表，对一个变量的修改会影响到另一个变量。这种方式类似于浅拷贝的行为。

而对于深拷贝，需要通过一些库或函数来递归复制表及其嵌套的表。

```lua
local originalTable = {a = 1, b = 2}
local deepCopy = table.deepCopy(originalTable)

function table.deepCopy(original)
    local copy = {}
    for key, value in pairs(original) do
        if type(value) == "table" then
            copy[key] = table.deepCopy(value) -- 递归复制嵌套表
        else
            copy[key] = value -- 复制普通值
        end
    end
    return copy
end
```

## 四、变量在堆栈中的操作

一般情况下，变量的存储和操作涉及到内存中的堆栈和堆两个概念。

内存堆栈和堆的存在是为了满足不同类型的数据存储和访问需求。堆栈适用于临时数据和函数调用，提供了高效的自动内存管理机制。而堆适用于动态分配的数据，虽然需要手动管理内存，但可以存储更大、更复杂的数据结构，并提供了灵活的空间分配。两者的结合使得计算机能够高效地管理和利用内存资源。

### 4.1 值类型和引用类型与堆栈的关系

1. 存储位置：值类型的变量通常存储在栈（Stack）上，而引用类型的对象存储在堆（Heap）上。栈和堆是内存中的两个不同的区域。
2. 内存管理：栈上的值类型变量由编译器自动管理，当超出作用域时会自动释放。栈采用先进后出（LIFO）的方式进行分配和释放。而引用类型的对象则由垃圾回收器（Garbage Collector）在堆上进行管理，当没有引用指向对象时，垃圾回收器会自动回收对象的内存。
3. 复制行为：将值类型的变量赋值给另一个变量时，会复制该值的副本，每个变量都有自己的独立内存空间。而将引用类型的变量赋值给另一个变量时，复制的是对象的引用（内存地址），两个变量指向同一个对象。
4. 性能和内存开销：栈上的操作速度较快，分配和释放内存的开销较小。对于值类型，变量的生命周期较短，栈的管理方式更适合。而堆上的操作速度较慢，分配和释放内存的开销较大。引用类型的对象的生命周期较长，需要动态分配和释放内存，因此存储在堆上。

引用类型的变量本身存储在栈上，用于存储对象的引用，而对象的实际数据存储在堆上。这意味着即使是引用类型的变量，在栈上存储的是一个指向堆上对象的引用。如`int[] arr = {1, 2, 3}`;变量`arr(数组名)`存储在栈中，变量`arr的值(数组元素)`存储在堆中(普通结构)。

### 4.2 堆栈中的一些概念

```cpp
int a= 0;//全局初始化区
char*p1;//全局未初始化区
main()
{
		int b;//栈
		char s[]= "abc";// 栈
		char*p2;//栈
		char*p3= "123456";//123456\0在常量区，p3在栈上。
		staticint c=0;//全局（静态）初始化区
        p1= (char*)malloc(10);//堆
        p2= (char*)malloc(20);//堆
}
```

- 栈中分配局部变量空间，堆区用于分配程序员申请的内存空间，静态区是分配静态变量，全局变量空间的；只读区是分配常量和程序代码空间的；以及其他一些分区。
- 栈区-由编译器自动分配和释放，一般存放函数的参数值、局部变量的值等（速度较快）；堆区-由程序员分配及释放，若程序员不释放，程序结束后可能由OS回收（速度比较慢，而且容易产生内存碎片）；

## 五、end

对于强类型语言，很好的理解值类型和引用类型可以帮助我们更好的去选择，和使用。从而避免一些性能消耗的操作，进而实现程序上的优化。例如装箱拆箱就是一个很耗的过程，在处理的时候要很小心；而在使用的过程中了解内存中分配，可以进一步帮助我们控制内存占用和降低内存泄漏的风险，这点对游戏开发来说还是很重要的。

## 参考链接

- [C# 类型系统 | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/types/)
- [堆栈的知识 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/34681978)