---
title: 解析C#深拷贝浅拷贝的问题
date: 2022-06-30 23:00:52
link: csharp-deep-and-shallow-copy-question
tags: c#-data-operate
categories: C#
---

深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在进行对象复制时使用的两种不同的拷贝方式。

浅拷贝适用于对象较简单、不包含引用类型成员或共享引用对象值的情况。而深拷贝适用于对象较复杂、包含引用类型成员且需要独立拷贝引用对象的情况。

一般情况下，默认是浅拷贝，而深拷贝则需要显式地操作或者通过特定的语言机制来实现。

### 什么是浅拷贝(Shallow Copy)

- 浅拷贝是指创建一个新对象，将原始对象的成员变量的值复制到新对象中。
- 对于引用类型的成员变量，浅拷贝只复制引用而不复制引用指向的对象本身。
- 因此，新对象和原始对象将共享相同的引用对象，对引用对象的修改会影响到新对象和原始对象。
- 浅拷贝可以通过语言提供的拷贝构造函数、赋值操作符等方式实现。

### 什么是深拷贝(Deep Copy)

- 深拷贝是指创建一个新对象，并将原始对象的所有成员变量的值复制到新对象中，包括引用类型的成员变量。
- 对于引用类型的成员变量，深拷贝会递归地复制引用指向的对象本身，而不仅仅是复制引用。
- 因此，新对象和原始对象拥有独立的、完全相同的数据副本，对任一对象的修改都不会影响另一个对象。
- 深拷贝可以通过自定义实现对象的 Clone 方法、序列化与反序列化等方式实现。

## 一、浅拷贝的实现

对于浅拷贝，可以使用C#的`MemberwiseClone`方法来实现。该方法会创建一个新对象，并将原始对象的字段值复制到新对象中。只需要在浅拷贝操作的类中重写`ICloneable`接口的`Clone`方法，并在其中直接调用`Object`的`MemberwiseClone`方法来完成浅拷贝。如果想借用此方法实现深拷贝，也可以在`Clone`方法中实现深拷贝的逻辑，即可。

```csharp
public class MyClass : ICloneable
{
    public int MyProperty { get; set; }
    
    public object Clone()
    {
        return this.MemberwiseClone();
    }
}

MyClass original = new MyClass { MyProperty = 10 };
MyClass copy = (MyClass)original.Clone();
```

## 二、深拷贝的实现

深拷贝的实现有三种方式：反射、序列化、表达式树。而在使用反射或序列化实现的时候又需要关注互相引用的问题，常规的手段是使用字典标记和深度限制。具体的实现如下，仅提供一种思路。

### 2.1 **使用反射实现深拷贝：**

```csharp
using System;
using System.Reflection;

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Address Address { get; set; }
}

public class Address
{
    public string City { get; set; }
    public string Country { get; set; }
}

public class DeepCopyExample
{
    public static T DeepCopy<T>(T source)
    {
        if (source == null)
            return default(T);

        Type type = source.GetType();
        if (type.IsValueType || type == typeof(string))
            return source;

        object target = Activator.CreateInstance(type);
        PropertyInfo[] properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        foreach (PropertyInfo property in properties)
        {
            if (property.CanWrite)
            {
                object value = property.GetValue(source);
                if (value != null)
                {
                    property.SetValue(target, DeepCopy(value));
                }
            }
        }
        return (T)target;
    }

    public static void Main()
    {
        Person person1 = new Person
        {
            Name = "John",
            Age = 30,
            Address = new Address
            {
                City = "New York",
                Country = "USA"
            }
        };

        // Perform deep copy
        Person person2 = DeepCopy(person1);

        // Modify person2
        person2.Name = "Jane";
        person2.Age = 25;
        person2.Address.City = "Los Angeles";

        // Print both objects
        Console.WriteLine("person1: Name={0}, Age={1}, Address.City={2}", person1.Name, person1.Age, person1.Address.City);
        Console.WriteLine("person2: Name={0}, Age={1}, Address.City={2}", person2.Name, person2.Age, person2.Address.City);
    }
}
```

### 2.2 **使用序列化的方式实现深拷贝：**

```csharp
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

[Serializable]
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

public class DeepCopyExample
{
    public static T DeepCopy<T>(T source)
    {
        if (!typeof(T).IsSerializable)
        {
            throw new ArgumentException("The type must be serializable.", nameof(source));
        }

        if (ReferenceEquals(source, null))
        {
            return default(T);
        }

        BinaryFormatter formatter = new BinaryFormatter();
        using (MemoryStream memoryStream = new MemoryStream())
        {
            formatter.Serialize(memoryStream, source);
            memoryStream.Seek(0, SeekOrigin.Begin);
            return (T)formatter.Deserialize(memoryStream);
        }
    }

    public static void Main()
    {
        Person person1 = new Person
        {
            Name = "John",
            Age = 30
        };

        // Perform deep copy using serialization
        Person person2 = DeepCopy(person1);

        // Modify person2
        person2.Name = "Jane";
        person2.Age = 25;

        // Print both objects
        Console.WriteLine("person1: Name={0}, Age={1}", person1.Name, person1.Age);
        Console.WriteLine("person2: Name={0}, Age={1}", person2.Name, person2.Age);
    }
}
```

### 2.3 **使用表达式树实现深拷贝：**

```csharp
using System;
using System.Linq.Expressions;

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

public class DeepCopyExample
{
    public static T DeepCopy<T>(T source)
    {
        if (source == null)
            return default(T);

        var parameter = Expression.Parameter(typeof(T));
        var memberBindings = Expression.MemberInit(Expression.New(typeof(T)), GetMemberBindings(source, parameter));
        var lambda = Expression.Lambda<Func<T, T>>(memberBindings, parameter);
        var deepCopyFunc = lambda.Compile();
        return deepCopyFunc(source);
    }

    private static MemberBinding[] GetMemberBindings<T>(T source, Expression parameter)
    {
        var type = typeof(T);
        var properties = type.GetProperties();
        var memberBindings = new MemberBinding[properties.Length];

        for (var i = 0; i < properties.Length; i++)
        {
            var property = properties[i];
            var valueExpression = Expression.Property(parameter, property);
            var value = property.GetValue(source);
            var valueCopy = value != null ? DeepCopy(value) : null;
            var valueCopyExpression = Expression.Constant(valueCopy, property.PropertyType);
            var memberBinding = Expression.Bind(property, valueCopyExpression);
            memberBindings[i] = memberBinding;
        }

        return memberBindings;
    }

    public static void Main()
    {
        Person person1 = new Person
        {
            Name = "John",
            Age = 30
        };

        // Perform deep copy using expression tree
        Person person2 = DeepCopy(person1);

        // Modify person2
        person2.Name = "Jane";
        person2.Age = 25;

        // Print both objects
        Console.WriteLine("person1: Name={0}, Age={1}", person1.Name, person1.Age);
        Console.WriteLine("person2: Name={0}, Age={1}", person2.Name, person2.Age);
    }
}
```

### 2.4 当要拷贝的对象有互相引用时，我们应该如何解决

当要拷贝的对象存在互相引用时，使用反射和表达式树的方式实现深拷贝需要特别处理以避免无限递归或循环引用。

在反射方式中，可以使用一个字典或哈希表来跟踪已经复制过的对象，以避免重复复制和无限递归的问题。在复制每个成员之前，可以检查该成员是否已经在字典中。如果存在，则直接使用字典中的复制对象，否则进行正常的复制操作并将复制对象添加到字典中。

```csharp
public static T DeepCopy<T>(T source, Dictionary<object, object> visitedObjects = null)
{
    if (visitedObjects == null)
        visitedObjects = new Dictionary<object, object>();

    if (source == null)
        return default(T);

    Type type = source.GetType();
    if (visitedObjects.ContainsKey(source))
        return (T)visitedObjects[source];

    if (!type.IsValueType && type != typeof(string))
    {
        object copyObject = Activator.CreateInstance(type);
        visitedObjects[source] = copyObject;

        PropertyInfo[] properties = type.GetProperties();
        foreach (var property in properties)
        {
            if (property.CanRead && property.CanWrite)
            {
                object propertyValue = property.GetValue(source);
                object propertyCopy = DeepCopy(propertyValue, visitedObjects);
                property.SetValue(copyObject, propertyCopy);
            }
        }

        return (T)copyObject;
    }

    return source;
}
```

而在表达式树方式中，可以使用一个参数表达式来表示要复制的对象，然后使用一个字典或哈希表来跟踪已经复制过的对象。在复制每个成员之前，可以检查该成员是否已经在字典中。如果存在，则直接使用字典中的复制对象，否则执行正常的复制添加操作。

```csharp
public static T DeepCopy<T>(T source, Dictionary<object, object> visitedObjects = null)
{
    if (visitedObjects == null)
        visitedObjects = new Dictionary<object, object>();

    if (source == null)
        return default(T);

    if (visitedObjects.ContainsKey(source))
        return (T)visitedObjects[source];

    var parameter = Expression.Parameter(typeof(T));
    var memberBindings = GetMemberBindings(source, parameter, visitedObjects);
    var lambda = Expression.Lambda<Func<T, T>>(Expression.MemberInit(Expression.New(typeof(T)), memberBindings), parameter);
    var deepCopyFunc = lambda.Compile();

    visitedObjects[source] = deepCopyFunc(source);

    return (T)visitedObjects[source];
}

private static MemberBinding[] GetMemberBindings<T>(T source, Expression parameter, Dictionary<object, object> visitedObjects)
{
    var type = typeof(T);
    var properties = type.GetProperties();
    var memberBindings = new MemberBinding[properties.Length];

    for (var i = 0; i < properties.Length; i++)
    {
        var property = properties[i];
        var valueExpression = Expression.Property(parameter, property);
        var value = property.GetValue(source);
        var valueCopy = DeepCopy(value, visitedObjects);
        var valueCopyExpression = Expression.Constant(valueCopy, property.PropertyType);
        var memberBinding = Expression.Bind(property, valueCopyExpression);

        memberBindings[i] = memberBinding;
    }

    return memberBindings;
}
```

## 三、深浅拷贝所解决的问题

1. 数据独立性问题：
    - 对象之间的复制通常是为了创建一个独立的、拥有相同或类似数据的新对象。
    - 浅拷贝可能会导致多个对象共享同一个引用对象，修改其中一个对象的数据会影响其他对象。
    - 深拷贝可以创建一个完全独立的对象，避免共享数据和不受影响的修改操作。
2. 对象引用问题：
    - 在某些情况下，对象的复制可能涉及到引用类型的成员变量，这些成员变量指向其他对象。
    - 浅拷贝只会复制引用而不会复制引用对象本身，导致多个对象引用同一个对象，修改其中一个对象的引用对象会影响其他对象。
    - 深拷贝会递归地复制引用对象本身，确保每个对象都拥有独立的引用对象。
3. 数据安全问题：
    - 在多线程环境下，多个线程可能同时访问和修改相同的对象。
    - 浅拷贝会导致多个线程共享同一个对象，可能引发并发读写问题和数据不一致性。
    - 深拷贝可以创建独立的对象副本，每个线程操作的是自己的对象，提供了更好的数据安全性。

在正常的编程语言中已经处理了深拷贝浅拷贝的操作，但一般默认是浅拷贝。如果想使用深拷贝，一般的对象也是引用类型，需要复制一份新的对象出来而不是执行它的引用，对于这块的内容加深对数据操作的理解，也相当于对值类型和引用类型的扩展。

## 参考链接

- [Object.MemberwiseClone 方法 (System) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.object.memberwiseclone?redirectedfrom=MSDN&view=netframework-4.7.2#System_Object_MemberwiseClone)
- [[C#进阶系列]专题一：深入解析深拷贝和浅拷贝 - Learning hard - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhili/p/DeepCopy.html)
- [C#对象属性浅拷贝和深拷贝 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/374537613)
- [C#数据结构-深拷贝和浅拷贝 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/349094034)