---
title: 外部资源文件导入Unity的一些优化设置
date: 2022-07-15 09:14:26
link: import-unity-asset-settings
tags: unity-asset
categories: Unity
---
实际项目中发现的许多问题都是源自无心之过：临时的“测试”更改和疲惫不堪的开发人员的误点击可能会暗地里添加性能不良的资源或更改现有资源的导入设置。

对于任何大规模的项目，最好是将防止人为错误作为第一道防线。编写一小段代码来禁止将 4K 未压缩纹理添加到项目中，是相对简单的事情。

但是，这种错误操作却是十分常见的。一个 4K 的未压缩纹理会占用 60 MB 的内存。在低端移动设备（如 iPhone 4S）上，占用的内存超过大约 180–200 MB 是十分危险的。如果误添加此类纹理，就会无意中占用应用程序内存预算的三分之一到四分之一，并导致难以诊断的内存不足错误。

## 一、Model(模型)

### 1.1 **禁用Read/Write enabled**

模型的”*Read/Write enabled“* 设置与纹理的具有相同的工作原理。但是，模型在默认情况下会启用该标志。

如果项目在运行时通过脚本修改网格 (Mesh)，或者如果网格用作 MeshCollider 组件的基础，则 Unity 会要求启用此标志。如果模型未在 MeshCollider 中使用并且未被脚本操纵，请禁用此标志以节省一半模型内存。

上文更具体的说法是在某些情况下禁用该选项也会导致“*MeshCollider*”不起作用：

- Mesh Collider的变换组件具有负缩放参数(如(-1,1,1))，且网格为凸面。
- Mesh Collider的变换组件是倾斜或截断的(例如，当旋转的变换组件具有缩放的父变换组件时)。
- Mesh Collider的“*Cooking Options*”选项设置为除默认值以外的任意值时。

### 1.2 **在非角色模型上禁用骨架**

默认情况下，Unity会为非角色模型导入通用骨架。如果模型在运行时实例化，则会被添加`Animator`组件。如果模型没有通过动画系统进行动画处理，则会给动画系统增加不必要的开销，因为每帧都必须运行一次所有激活的Animator。

在非动画模型上禁用骨架可以避免自动添加Animator组件，并防止向场景添加不需要的Animator。

### 1.3 **在动画模型上启用Optimize Game Objects**

“*Optimize Game Objects“*选项对动画模型有着显著的性能影响。禁用该选项后，Unity会在每次实例化模型时创建一个大型变换层级视图来镜像模型的骨骼结构。此变换层级视图的更新成本很高，尤其是在附加了其他组件（如粒子系统或碰撞体）的情况下。它还限制了Unity通过多线程执行网格蒙皮和骨骼动画计算的能力。

如果需要暴露模型骨骼结构上的特定位置（例如暴露模型的双手以便动态附加武器模型），则可在
“*Extra Transforms*”列表中将这些位置专门设为允许状态。

如需了解更多详细信息，请参阅 Unity 手册的 [Model Importer](https://docs.unity3d.com/Manual/FBXImporter-Rig.html) 页面。

### 1.4 **尽可能使用网格压缩(Mesh Compression)**

通过使用网格边界和每个组件较低的位深度来压缩网格数据，增加压缩率会降低网格的精度。最好在 `Mesh` 看起来与未压缩版本没有太大区别的情况下将其调得尽可能高。这对于优化游戏大小很有用

![Untitled](/images/202207/import-unity-asset-settings-1.webp)

*请注意，可对不同的通道使用不同级别的压缩，因此项目可选择仅压缩切线和法线，同时保持UV和顶点位置不压缩。*

### 1.5 **注意网格渲染器设置**

将网格渲染器添加到预制件或游戏对象时，请注意组件上的设置。默认情况下，Unity会启用阴影投射和接收、光照探针采样、反射探针采样和运动矢量计算。

如果项目不需要这些功能，需要通过自动脚本关闭。添加网格渲染器的任何运行时代码也都需要处理这些设置。

对于2D游戏，在启用阴影选项的情况下意外地将网格渲染器添加到场景会为渲染循环添加完整的阴影pass。通常情况下，这是对性能的浪费。

### 1.6 LOD

LOD即Levels of Detail，翻译过来就是多层次细节，类似与纹理渲染的Mip map技术，同样是一种根据渲染距离设置渲染精度的一种技术。其实现方式是在游戏开发时，美术根据不同的渲染距离制作一组不同精度的模型，导入到Unity通过LOD组件连接其这一组模型，并设置相关参数。这样在游戏运行时，就会在不同的距离有不同的渲染精度。

使用LOD后，模型随着渲染距离的增加，渲染精度逐渐下降，直到最终被剔除，这样做的优势是保证游戏画面表现的同时，可以最大程度降低渲染压力。简单的理解，如果不采用LOD，随着距离增加，物体占用的屏幕像素就会越少，那么单位像素的三角面数就会越多。单位的渲染压力就会增大。画面表现需求不高的地方渲染压力反而更高，这显然是不合理的。所以就需要通过LOD来解决这样的问题。

当然这种技术本身也是有相当大的缺陷的，首先就是会增大包体的体积，同时也会增加美术的工作量。所以在实际开放中，一般只会对一些重要的对象使用该技术。

### 1.7 模型导入前的优化

DCC 中模型导出时，Unity 支持多种标准和专有模型文件格式（DCC）。Unity 内部使用 `.fbx` 文件格式作为其导入链。最佳做法尽可能使用 `.fbx` 文件格式，并且不应在生产中使用专有文件格式。

优化原始导入模型文件，删除不需要的数据

- 统一单位，避免DCC工具中的单位和Unity中的单位出现不一致的情况
- 导出的网格必须是多边形拓扑网格，不能是贝塞尔曲线、样条曲线、NURBS、NURMS、细分曲面等
- 烘培”*Deformers“*, 在导出之前，确保变形体被烘培到网格模型上，如骨骼形变烘培到蒙皮权重上
- 不建议模型使用到的纹理随模型导出，纹理应该单独给出
- 如果需要导入”*blend shape normals“*，必须要指定光滑组”*smooth groups“*，当然也不是全部都需要指定
- DCC导出面板设置，不建议携带场景信息导出，如不建议导出摄像机、灯光、材质等信息，因为这些的信息与 Unity内默认都不同。除非你自己为某DCC做过自定义导出插件。

### 1.8 原始模型对性能影响的点

- 最小化面数，不要使用微三角形（三角形内只有个位数像素即微三角形），分布尽量均匀，尽量使用 LOD
- 合理的网络拓扑和平滑组，尽可能是闭包，避免后期 Unity 烘焙错误，避免产生额外的三角形顶点和边
- 尽量少的使用材质个数，材质数量的增多会引起 Shader 和贴图的暴涨
- 尽可能少的使用蒙皮网格，同一个模型尽量尽量使用同一个蒙皮网格
- 尽可能少的骨骼数量，过多骨骼数量会引起蒙皮动画的 CPU、GPU 双方的性能瓶颈
- 原始模型中的 FK 与 IK 节点分离，Unity 中不支持导入的 IK 骨骼，导出时需要删除 IK 节点

### 1.9 其他需要注意点

- 尽可能的将网格合并到一起
- 尽可能使用共享材质，单个模型尽量使用单个材质
- 不要使用网格碰撞体
- 不必要不要开启网格读写，否则会存在内存和显存中两份模型资源
- 使用合理的LOD级别，可以参考[https://docs.unity3d.com/cn/2020.3/Manual/LevelOfDetail.html](https://docs.unity3d.com/cn/2020.3/Manual/LevelOfDetail.html)
- *Skin Weights*受骨骼影响个过多
- 合理压缩网格，减化网格，避免出现全部是精细模型，比如一个石头就有上万的顶点数量肯定是不合理的
- 不需要*rigs*和*BlendShapes*尽量关闭
- 如果可能，禁用法线或切线
- 多套模型

## 二、Texture(纹理)

### 2.1 **禁用read/write enabled标志**

`Read/Write enabled` 标志使纹理在内存中保留两次：一次保存在GPU中，一次保存在CPU可寻址内存中（注意： 这是因为大多数平台上从 GPU 内存回读的速度极慢。将纹理从GPU内存读入临时缓冲区以供CPU代码（例如 Texture.GetPixel）使用将是非常低效的）。

在 Unity 中，默认情况下禁用此设置，但可能会无意中将其打开。

只有在着色器之外操作纹理数据时（例如使用 `Texture.GetPixel` 和 `Texture.SetPixel` API 时）才需要 `Read/Write Enabled`，否则应尽可能避免使用它。

### 2.2 **尽可能禁用Mipmap**

如果对象相对于摄像机具有固定的深度距离，则可禁用Mipmap，这样将大约节省加载纹理所需内存的三分之一。如果对象的深度距离不固定，则禁用Mipmap可能导致GPU上的纹理采样性能变差。

通常情况下UI和2D贴图不会改变渲染精度，会禁用此选项。

Mip Map类似于模型的LOD，同样是一种基于渲染距离改变渲染贴图精度的技术。其优势是在物体距离渲染距离比较远时，可以节省性能。但是使用Mip Map时会增大内存占用量。

Mip map的技术原理是根据原始图进行2的幂次方的递减来生成一组不同精度的图片。当游戏运行时，会将这组图片加载到内存中，然后根据渲染的距离不同，来使用不同精度的图片。

Mip map会增大多大的内存占用量呢？在我们使用Mip map时，假设大小为256X256，并且会生成8张不同精度的图片。根据2的幂次方进行递减计算每张贴图大小并累加。这样最终得到的图片组的体积大概比原来的单张贴图大33%

### 2.3 **压缩所有纹理**

Unity基于多适配性，没有一股脑的把不同的文件压缩成一个格式，而是把设置开放出来，可以让开发者基于项目、基于平台进行更细粒度的控制。

即使在同一平台，也会根据不同的情况有着不同的压缩需求，比如有一些关键的主页面图片，玩家感知强的地方，就对图片的质量要求高些，一些边角的辅助图片，可能要求就低一些，如果都使用高质量压缩，性能方面就造成了浪费，但若都是用低质量压缩，质量又跟不上。所以，同样需要根据实际需求选择不同的压缩格式。

有张经典的图片介绍不同压缩格式的特点与适用场景：

![Snipaste_2023-06-08_16-44-00.jpg](/images/202207/import-unity-asset-settings-2.webp)

使用适合项目目标平台的纹理压缩格式对于节省内存至关重要。

如果所选的纹理压缩格式不适合目标平台，Unity 会在加载纹理时解压缩纹理，这将消耗 CPU 时间和额外的内存。此问题在 Android 设备上最常见，因为此类平台通常因芯片组不同而支持截然不同的纹理压缩格式。RGB32和RGB24等非压缩格式纹理占用内存较大。

1. Android平台：
    - ETC2：适用于大部分Android设备的压缩格式，具有较高的质量和压缩比。可以在导入设置中选择ASTC格式，根据设备支持程度进行调整。
    - ETC1：适用于性能较低的设备，压缩比较高但质量稍低。在低端设备上，可以考虑使用ETC1格式。
2. iOS平台：
    - ASTC：适用于支持ASTC纹理压缩的iOS设备，提供高质量和高压缩比。可以使用ASTC格式来获得较好的视觉效果和性能。
    - PVRTC：适用于老旧的iOS设备，提供较高的压缩比但质量相对较低。在旧款设备上，可以使用PVRTC格式来进行纹理压缩。
3. PC和主机平台：
    - BC系列：适用于PC和主机平台，如DXTC（DXT1、DXT5）、BC1、BC3等。具有较高的压缩比和较好的视觉质量，适用于大部分PC和主机设备。

### 2.4 **实施合理的纹理大小限制**

虽然很简单，但也很容易忘记调整纹理大小或无意中更改纹理大小导入设置。应确定不同类型纹理的合理最大值，并通过代码强制执行这些限制规则。

对于许多移动应用程序，2048x2048 或 1024x1024 足以满足纹理图集的要求，而 512x512 足以满足应用于 3D 模型的纹理的要求。

### 2.5 打包图集

图集的打包主要是优化UI图形渲染过程中Draw call的数量，其基本原理也是通过UI元素合批来减少Draw Call，进入提升CPU的性能表现，关于其具体细节，将会另开一个坑说明。

## 三、Audios(音频)

### 3.1 音频格式选择

几种常见的音频压缩格式对比以及它们适用的平台：

1. **MP3（MPEG-1 Audio Layer 3）**：MP3 是一种广泛使用的有损音频压缩格式，具有较好的压缩比和广泛的平台支持。MP3 格式适用于多个平台，包括 PC、主机游戏、移动设备和网络游戏等。
2. **AAC（Advanced Audio Coding）**：AAC 是一种高级音频编码格式，与 MP3 相比，它通常具有更好的音频质量和更小的文件大小。AAC 格式广泛用于移动设备和流媒体平台，如 iOS、Android、Web 和流媒体服务。
3. **OGG Vorbis**：OGG Vorbis 是一种开源的无损音频压缩格式，具有较好的音频质量和相对较小的文件大小。OGG Vorbis 格式适用于多个平台，包括 PC、主机游戏、移动设备和网络游戏等。
4. **FLAC（Free Lossless Audio Codec）**：FLAC 是一种无损音频压缩格式，能够保持音频的原始质量，但文件大小相对较大。FLAC 格式主要适用于对音频质量要求较高的平台，如高保真音频播放器和音乐制作工具。
5. **WAV（Waveform Audio File Format）**：WAV 是一种无损音频格式，不进行压缩。它适用于游戏开发过程中的中间文件、音频编辑和处理等环节，不适合作为最终游戏发布的音频格式，因为文件大小较大。

### 3.2 **适合平台的压缩设置**

为音频设置与平台匹配的压缩格式。如iOS设备都包含硬件MP3解压器，而许多Android设备则本身就支持Vorbis。

移动平台大多数声音尽量采用 Vorbis 压缩设置，IOS平台或不打算循环的声音可以选择MP3格式，对于简短、常用的音效，可以采用解码速度快的ADPCM格式（PCM为未压缩格式）

*注：对[PCM格式的解读](http://www.shaoguoji.cn/2019/08/05/hardcore-audio-1/)(扩展知识)。*

此外，应将未压缩的音频文件导入Unity。Unity 在构建项目时会重新压缩音频，无需把导入压缩的音频再重新压缩，这样只会降低最终音频剪辑的质量。

### 3.3 **设置声道**

移动设备实际上很少配备有立体声扬声器。在移动平台项目中，将导入的音频剪辑强制设置为单声道(”*Force to Mono*”)，可以使其内存消耗减半。此设置也适用于没有立体声效果的任何音频剪辑，例如大多数UI声音效果。

### 3.4 设置音频加载类型

- 简短音效导入后小于 200kb，采用 “*Decompress on Load“* 模式
- 对于复杂音效，大小大于 200kb，长度超过 5 秒的音效采用 ”*Compressed In Memory“* 模式
- 对于长度较长的音效或背景音乐则采用 ”*Streaming“* 模式，虽然会有CPU额外开销，但节省内存并且加载不卡顿

### 3.5 **降低音频比特率**

降低音频的位深度和采样率可以减小文件大小。对于游戏中的音效和背景音乐，可以适当降低位深度（如从16位降至8位）和采样率（如从44.1kHz降至22.05kHz），以减小文件大小并降低解码开销。但需要注意降低位深度和采样率会损失一部分音频质量。但这种情况需要咨询音频设计师。

## 四、****AssetPostprocessor****

[AssetPostprocessor - Unity 脚本 API](https://docs.unity3d.com/cn/current/ScriptReference/AssetPostprocessor.html)

Unity Editor 中的 `AssetPostprocessor` 类可用于在 Unity 项目上强制执行某些最低标准。导入资源时将回调此类。要使用此类，应继承 `AssetPostprocessor` 并实现一个或多个 `OnPreprocess` 方法。重要的方法包括：

- `OnPreprocessTexture`
- `OnPreprocessModel`
- `OnPreprocessAnimation`
- `OnPreprocessAudio`

```csharp
public class ReadOnlyModelPostprocessor : AssetPostprocessor {
   public void OnPreprocessModel() {
        ModelImporter modelImporter = (ModelImporter)assetImporter;
        if(modelImporter.isReadable) {
            modelImporter.isReadable = false;
            modelImporter.SaveAndReimport();
        }
    }
}
```

这是一个在项目中 `AssetPostprocessor` 强制执行规则的简单示例：

每次将模型导入项目时，或者模型的导入设置发生更改时，都会调用此类。该代码只是检查 `Read/Write enabled` 标志（由 `isReadable` 属性表示）是否设置为 `true`。如果是，则强制将标志位更改为 `false`，然后保存并重新导入资源。

请注意，调用 `SaveAndReimport` 会导致再次调用此代码片段！但是，因为现在已确保 `isReadable` 为 false，所以此代码不会产生无限的重新导入循环。

## 五、参考链接

- [优化移动端游戏性能：图形和资源的专家级贴士 | Unity Blog](https://blog.unity.com/cn/games/optimize-your-mobile-game-performance-expert-tips-on-graphics-and-assets)
- [资源审核 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/current/Manual/BestPracticeUnderstandingPerformanceInUnity4.html)
- [Unity3D性能优化之资源导入标准和属性设置篇 - 学习使我进步 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wwhhgg/p/12931173.html)