<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一剑光寒耀九州</title>
  
  
  <link href="http://huozk.cn/atom.xml" rel="self"/>
  
  <link href="http://huozk.cn/"/>
  <updated>2023-05-25T11:20:15.281Z</updated>
  <id>http://huozk.cn/</id>
  
  <author>
    <name>Nil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[译]Unity基础教程：(一)创建一个时钟</title>
    <link href="http://huozk.cn/2022/06/catlike-base-building-a-clock/"/>
    <id>http://huozk.cn/2022/06/catlike-base-building-a-clock/</id>
    <published>2022-06-15T02:46:42.000Z</published>
    <updated>2023-05-25T11:20:15.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用简单的对象构建一个时钟。</p><p>写一个C#脚本。</p><p>转动时钟的指针以显示时间。</p><p>对钟臂进行动画处理。</p></blockquote><p>这是关于学习使用Unity基础知识的系列教程中的第一个教程。在本教程中，我们将创建一个简单的时钟，并对脚本组件进行编程，让它显示当前时间。你不需要有任何使用Unity编辑器的经验，但需要你有一些使用多窗口编辑器应用程序的经验。</p><p>在我所有教程的底部，你可以找到教程许可证的链接，包含完成的教程项目的资源库，以及教程页面的PDF版本。</p><p>本教程是用Unity 2020.3.6f1制作的。</p><p><img src="https://static.huozk.cn/20220814-4585c7a8fa39ec03fbfc78ffaccc5b41555bc348a1e5f61f605b11e12c84ccca.jpg" alt="这是时钟的最终效果"></p><h1 id="Creating-a-Project"><a href="#Creating-a-Project" class="headerlink" title="Creating a Project"></a>Creating a Project</h1><p>在开始使用Unity编辑器之前，我们必须首先创建一个项目。</p><h2 id="1-1-新项目"><a href="#1-1-新项目" class="headerlink" title="1.1 新项目"></a>1.1 新项目</h2><p>当你打开Unity时，你会看到Unity Hub。这是一个启动器和安装程序，在这里你可以创建或打开项目，以及安装管理Unity版本，并做一些其他事情。如果你没有安装Unity2020.3或更高版本，现在就请添加它吧。</p><details>    <summary>哪些Unity版本是合适的？</summary>    <p>Unity每年会发布很多个新版本。其中有两个平行版本发布时间表。最稳定和安全的是LTS版本。LTS代表长期支持，在Unity说明下是支持两年。</p>    <p>我的教程坚持使用LTS版本，其中2020.3是最新版本。本教程特别使用2020.3.6。版本号的第三部分表示补丁版本。补丁版本包含错误修复，很少有新功能。另一个f1后缀表示官方最终版本。任何2020.3版本都可以用于本教程。</p></details><p>最高的Unity版本，如2021.1 通常属于开发分支，它很可能引入了新的功能，也可能删除了旧的功能。这些版本并不像LTS版本那样可靠，每个版本仅有几个月的支持时间。</p><p>偶尔教程中包含一些提问回答环节，<del>它们被包装在灰色的格子里，就像上面那样。在页面中，答案默认是隐藏的。可以通过点击问题来打开关闭。</del>（注：译文中使用引用格式处理！）</p><p>当我们创建一个新项目时，可以选择它的Unity版本和初始化模板。我们将使用标准的3D模板。一旦它被创建，它就会被添加到项目列表中，并在Unity编辑器的选定版本中被打开。</p><details>    <summary>我可以用不同的渲染管线来创建一个项目吗？</summary>    <p>可以，唯一的区别是，项目的默认场景中会有更多的东西，你的材质看起来也会不同。你的项目也会包含相应的包。</p></details><h2 id="1-2-编辑界面布局"><a href="#1-2-编辑界面布局" class="headerlink" title="1.2 编辑界面布局"></a>1.2 编辑界面布局</h2><p>如果你还没有设置编辑器布局，最终将使用默认的窗口布局。</p><p><img src="https://static.huozk.cn/20220814-32bf9f548c61a327ae415929fa14c15bc12eea0f61fe28f4ca68d8a0db25d3c7.jpg" alt="默认的编辑器布局。">  </p><p>默认布局包含了我们需要的所有窗口，但可以按照你自的意思，通过重新排布和分组窗口来设置。也可以打开和关闭某些窗口，比如资源商店(Asset Store)的窗口。每个窗口都有自己的配置选项，可以通过窗口右上角的三点按钮进入。除此之外，大多数窗口都有一个带有更多选项的工具条。如果你的窗口看起来与教程中的不一样；例如，场景窗口(Scene)有一个统一的背景而不是一个天空盒，那么它的某个选项是不一致的。</p><p>还可以通过Unity编辑器右上方的下拉菜单切换到一个预先配置好的布局。也可以在那里保存你当前的布局，这样可以在以后需要的时候恢复。</p><h2 id="1-3-包"><a href="#1-3-包" class="headerlink" title="1.3 包"></a>1.3 包</h2><p>Unity的功能是基于模块化的。除了核心功能，还有一些额外的包可以下载并且引入到你的项目中。默认的3D项目中也包含了一些默认的包，你可以在项目窗口(Project)的<em>Packages</em>下看到这些包。</p><p><img src="https://static.huozk.cn/20220814-947cc4a052fa4e80a127116c11a25c1a41b0061a7e9727a6c5dc511af86f8e5c.png" alt="3D模板默认引入包">  </p><p>这些包可以被隐藏，方法是点击项目窗口(Project)右上方类似眼睛的按钮，上面有一个破折号。这纯粹是为了减少编辑器中的视觉混乱，这些包仍然是项目的一部分。这个按钮还显示有多少个这样的包。</p><p>你可以通过包管理器来管理哪些包可以被包含在你的项目中，包管理器可以通过 <em>Window&#x2F;Package Manager</em> 选项打开。</p><p><img src="https://static.huozk.cn/20220814-fc45df6641f8f925649df9bdab8c6be338bbaba172494fe4ab93eb3bc2c04166.png" alt="包管理器，只显示项目中已经引用的包。"> </p><p>这些包为Unity增加了额外的功能。例如，Visual Studio Editor增加了对Visual Studio编辑器的支持，用于编写代码。本教程不会使用项目中已引用包的功能，所以我把它们都删除了。唯一的例外是Visual Studio Editor，因为那是我用来写代码的编辑器。如果你使用其他的编辑器，如果它的集成包存在的话，你可以导入它。</p><details>    <summary>你不也需要Visual Studio代码编辑器包吗？</summary>    <p>尽管名字相似，但Visual Studio和Visual Studio Code是两个不同的编辑器。你只需要其中一个包，这取决于你使用哪一个编辑器。</p></details><p>移除软件包的最简单方法是，首先使用工具栏将软件包列表限制为只在项目中(In Project)。然后依次选择一个包并使用窗口右下方的移除按钮(Remove)。Unity在每次删除后都会重新编译，所以需要几秒钟才能完成这个过程。</p><p>移除除了Visual Studio Editor以外的所有引入包后，可以看到在项目窗口(Project)中只剩下三个包：Custom NUnit, Test Framework, 和Visual Studio Editor。其他两个仍然存在，因为Visual Studio Editor依赖于它们。</p><p>你还可以通过项目设置窗口(Project Settings)使依赖和隐藏导入的包在包管理器中可见，通过<em>Edit &#x2F; Project Settings…<em>打开。选择其包管理器类别，然后在高级设置下启用</em>Show Dependencies</em>。</p><p><img src="https://static.huozk.cn/20220814-0c97bc29349d4873128f9656cd7c7c95876d2162400b6e36d68df5e446ea1914.jpg" alt="包管理项目设置，打开Show Dependencies。"> </p><p>包管理项目设置，打开Show Dependencies。</p><h2 id="1-4-颜色空间"><a href="#1-4-颜色空间" class="headerlink" title="1.4 颜色空间"></a>1.4 颜色空间</h2><p>现在的渲染通常是在线性色彩空间中进行的，但是Unity仍然默认配置为使用伽马色彩空间。为了获得最佳的视觉效果，选择项目设置窗口(Project Settings)中的播放器(Player)类别，打开其他设置(Other Settings)面板，向下滚动到其渲染部分(Rendering)。确保色彩空间(Color Space)被设置为线性(Liner)。Unity会显示警告，这可能需要很长的时间，但对于一个几乎是空的项目来说，不会出现这种情况。确认切换。</p><p><img src="https://static.huozk.cn/20220814-4114a4a838a9023df3955f44ede2be51a9f8f9ebb926e02c5f3dacb0ec00b0ab.png" alt="色彩空间设置为线性。"></p><details>    <summary>有理由使用伽马色彩空间吗？</summary>    <p>只有当你的目标平台是旧硬件或旧的图形API的时候。OpenGL ES 2.0和WebGL 1.0不支持线性空间，此外，在老旧的移动设备上，伽玛可以比线性空间更快。</p></details><h2 id="1-5-示例场景-Sample-Scene"><a href="#1-5-示例场景-Sample-Scene" class="headerlink" title="1.5 示例场景(Sample Scene)"></a>1.5 示例场景(Sample Scene)</h2><p>新项目中包含一个名为Sample Scene的示例场景，默认打开。你可以在项目窗口(Project)的<em>Assets&#x2F;Scenes</em>下找到它。</p><p><img src="https://static.huozk.cn/20220814-8db777a39687111a3ec7195e6366c8d026b436e949238365ac0c94e1bafc7fdb.png" alt="项目窗口中的样例场景。">  </p><p>默认情况下，项目窗口(Project)使用两栏式布局(Two Column Layout)。你可以通过它的三点式配置菜单选项切换到单栏布局(One Column Layout)。</p><p><img src="https://static.huozk.cn/20220814-f489bed22ccbcceb4c1b0ee18e86e90f97130aa780bd5f90e2ac13d6b8049aa6.png" alt="一栏式布局。">  </p><p>这个样本场景包含一个主摄像机(Main Camera)和一个定向灯光(Direction Light)。这些都是游戏对象。它们被列在层次结构窗口(Hierarchy)中，在场景的下面。</p><p><img src="https://static.huozk.cn/20220814-2a53fe3188f81a7d7ac2d4d69cb3ec910b308539ae50a3dcd1437f505a594d1f.png" alt="场景中的对象层次。">  </p><p>你可以通过层次结构窗口(Hierarchy)或场景窗口(Scene)选择一个游戏对象。相机有一个场景图标，看起来像一个老式的胶片相机，而定向灯的图标则看起来像一个太阳。</p><p><img src="https://static.huozk.cn/20220814-b6c136e50147c5f6e402b12a1640242f94c5e8355e4cb6cb9d128b45964bd3bf.png" alt="场景窗口中的图标。">  </p><details>    <summary>如何在场景窗口中进行导航？</summary>    <p>你可以使用alt或option键与鼠标结合来旋转视图。也可以使用方向键来移动视点，并通过鼠标滚轮进行缩放。另外，按F键可以将视角聚焦到当前选定的游戏对象上。当然，还有其他更多的可操作性，但这些足以让你在场景中找到方向。</p>    <p>当一个物体被选中时，关于它的详细信息将显示在检查器窗口(Inspector)中，但我们会在需要时再介绍这些。我们不需要修改摄像机和灯光，所以我们可以通过点击层次结构窗口(Hierarchy)中它们左边的眼睛图标来把它们在场景中隐藏起来。这个图标在默认情况下是不可见的，但是当我们把鼠标光标悬停在游戏对象前面时，就会出现。这么做纯粹是为了减少场景窗口中的视觉杂乱。</p></details><p><img src="https://static.huozk.cn/20220814-76790001af396bbcb80832b277a3da8159715bd03abe06ad015f0cd8717603da.png" alt="隐藏的物体。">  </p><details>    <summary>眼睛旁边的手状图标是做什么的？</summary>    <p>在包含眼睛图标的那一列旁边，有着类似手的图标。这些图标在默认情况下也是不可见的。只有当一个游戏对象的手部图标处于活动状态时，不可以通过场景窗口(Scene)选择该对象。这样你就可以通过在场景窗口(Scene)点击选中的反应来控制对象。</p></details><h1 id="创建一个简单的时钟"><a href="#创建一个简单的时钟" class="headerlink" title="创建一个简单的时钟"></a>创建一个简单的时钟</h1><p>现在我们的项目已经正确设置好了，可以开始创建我们的时钟了。</p><h2 id="2-1-创建一个游戏对象"><a href="#2-1-创建一个游戏对象" class="headerlink" title="2.1 创建一个游戏对象"></a>2.1 创建一个游戏对象</h2><p>首先需要一个游戏对象来表示时钟。我们将从最简单的游戏对象开始，也就是一个空的游戏对象(空物体)，可以通过<em>GameObject&#x2F;Create Empty</em>选项来创建。另外，你也可以使用层次结构窗口(Hierarchy)的上下文菜单中的<em>Create Empty</em>选项，还可以通过另一种方式点击打开，通常是右击或用两根手指敲击。这将把创建的游戏对象添加到场景中。它显示在SampleScene场景下的层次结构窗口(Hierarchy)中，并处于被选中状态，现在场景名字旁边被标记为星号，表示它有未保存的修改，记得保存。现在你可以修改名字，或者以后再做更改。</p><p><img src="https://static.huozk.cn/20220814-0a1a02dff4309ed83b76a6d74d67178e31226f072dcf7847b4d49d0518c5a890.png" alt="选择了新游戏对象的层次结构窗口。">  </p><p>选择了新游戏对象的层次结构窗口。</p><p>只要游戏对象处于被选中的状态，检查器窗口(Inspector)就会显示它的详细信息。顶部是标题，上面有对象的名称和一些其他的配置。默认情况下，该对象是被启用的，且不是静态的，没有被更改标签，位于默认层级上。这些设置都不用做修改，我们需要把它重命名为时钟(Clock)。</p><p><img src="https://static.huozk.cn/20220814-a297cb552889d22d43f21775b0b5af0c0d3dcdcdce89e36ee94b93feff7813e8.png" alt="选定时钟的检查器窗口。">  </p><p>标题下面是该游戏对象的所有组件列表。每个3D对象的顶部总会有一个<code>Transform</code>组件，这就是时钟目前拥有的所有组件。它的作用主要是控制游戏对象的位置、旋转角度和大小比例。现在确保所有时钟的位置和旋转角度都设置为0，其大小比例应该统一为1。</p><details>    <summary>2D对象怎么办？</summary>    <p>当使用的是2D而不是3D对象时，你可以忽略三个维度中的一个。对于专门用于2D的对象，如UI，通常有一个<code>RectTransform</code>来代替<code>Transform</code>，它是一个特殊的<code>Transform</code>组件。</p></details><p>因为游戏对象是空的，它在场景窗口(Scene)中是处于不可见的。不过，在游戏对象的位置，也就是在世界的中心，可以看到一个操作工具。</p><p><img src="https://static.huozk.cn/20220814-5c2cc39e31c9260e95c9afe10a0d7113ac714ef955d2b36fdda6a79ce723738b.png" alt="用移动工具选择。">  </p><details>    <summary>为什么我在选择时钟(clock)后没有看到操纵工具？</summary>    <p>操纵工具存在于场景窗口(Scene)中。请确保你看到的是场景窗口(Scene)，而不是游戏窗口(Game)。</p></details><p>当前处于哪个操纵工具，可以通过编辑器工具栏左上方的按钮来控制。这些模式也可以通过快捷键Q、W、E、R、T和Y键激活。该组中最右边的按钮是用来启用自定义编辑器工具的，我们没有这个工具。默认情况下，移动工具是激活的。</p><p><img src="https://static.huozk.cn/20220814-557da9fe4bd16dfa2d2b8c1debbc3dabbd0ee418135b696ef1144be2a38cf395.jpg" alt="操纵模式工具栏。">  </p><p>在模式按钮旁边还有三个按钮，用来控制操作工具的位置、方向和捕捉。</p><h2 id="2-2-创建时钟的表盘"><a href="#2-2-创建时钟的表盘" class="headerlink" title="2.2 创建时钟的表盘"></a>2.2 创建时钟的表盘</h2><p>虽然我们已经拥有一个时钟对象，但还没有看到任何东西。现在必须给它添加3D模型，这样才能有物体被渲染出来。Unity内置了一些原始游戏对象，可以通过使用它们来建立一个简单的时钟。让我们首先通过<em>GameObject&#x2F;3D Object&#x2F;Cylinder</em>向场景添加一个圆柱体，确保它具有与我们的时钟相同的<code>Transform</code>数值。</p><p><img src="https://static.huozk.cn/20220814-679b08215ae6851c0d5949401baf85bbf6d8e8ed58e37689960d6293d2c07dc4.png" alt="代表一个圆柱体的游戏对象。">  </p><p>新对象比一个空对象多了三个组件。首先，它有一个<code>MeshFilter</code>，它包含了对内置圆柱体网格的引用。</p><p><img src="https://static.huozk.cn/20220814-03e3e6c3f509647df6cb084ba720a3c7967b05693e7a0cb713f2f08a1bb1555d.png" alt="MeshFilter组件，设置为圆柱体。">  </p><p>其次是一个<code>MeshRenderer</code>。这个组件的作用是确保对象的网格被渲染出来。它也决定了渲染时使用什么材质，也就是默认材质。这个材质也会显示在检查器中，在组件列表的最下面。</p><p><img src="https://static.huozk.cn/20220814-571f9f5b5ba1ab3dbc226892abf0183cd27403f108de6c37370c3a9ee91acf99.png" alt="MeshRenderer组件，设置为默认材质。">  </p><p>第三个是<code>CapsuleCollider</code>，它用于3D物理模拟。这个物体代表一个圆柱体，但它有一个胶囊碰撞器，因为Unity没有一个原始的圆柱体碰撞器。而且我们不需要它，所以可以删除这个组件。如果你想让时钟具有物理效果，最好使用<code>MeshCollider</code>组件。组件可以通过其右上角的三点式下拉菜单来移除(Remove Compont)。</p><p><img src="https://static.huozk.cn/20220814-e26c420c9e2cd19202493b4848acc26c95b1d5316fb49ae198ffb7daff8b3010.png" alt="没有碰撞器的圆柱体。">  </p><p>我们将通过压扁圆柱体来把它变成时钟的表盘。这是通过减少其大小比例的Y值来实现，把它减少到0.2。由于圆柱体的网格有两个单位高，它的有效高度变成了0.4个单位。让我们制作一个比较大的时钟，所以应该将其比例的X和Z值增加到10。</p><p><img src="https://static.huozk.cn/20220814-8d148be27b36dc1fba347eadd0cafd209298f10ef68a7bbf80dca7a3fa8192c6.png" alt="缩放的圆柱体。 ">  </p><p>时钟应该是竖直立在或挂在墙面上的，但它的表盘目前是平躺着的。我们可以通过将圆柱体旋转四分之一圆的角度来解决这个问题。在Unity中，X轴指向右边，Y轴指向上方，Z轴指向前方。为了让我们在设计时钟时考虑到相同的方向，也就是说，当我们沿着Z轴看它时，我们可以看到它的正面。需要设置圆柱体的X值即旋转角度为90，并调整场景视图，使时钟的正面可见，所以移动工具的蓝色Z轴箭头指向远离你的方向，穿透屏幕。</p><p><img src="https://static.huozk.cn/20220814-8595906dbe17dfa15317e5991459bbc2c01b177b531d9eea875edb690cb8790b.png" alt="旋转的圆柱体。">  </p><p>将圆柱体对象的名称改为<em>Face</em>，因为它代表了时钟的表盘。但是它只是时钟的一个部分，所以让它成为时钟对象的一个子对象。我们通过在层次结构窗口(Hierarchy)中把表盘(Face)拖到时钟上来实现这一点。</p><p><img src="https://static.huozk.cn/20220814-f6e2da5748997972c9bd89c085bab25b05db3939f6c23679f50dc3d9348741df.png" alt="钟表子对象表盘。">  </p><p>子对象受制于其父对象的变换。这意味着当时钟(Clock)改变位置时，表盘(Face)也会跟随改变。这就好像它们是一个单一的实体。旋转和缩放也是如此。你可以用它来制作复杂的对象层次。</p><h2 id="2-3-创建时钟刻度"><a href="#2-3-创建时钟刻度" class="headerlink" title="2.3 创建时钟刻度"></a>2.3 创建时钟刻度</h2><p>钟表表面的外环通常有标记，有助于表明显示的时间。这就是所谓的时钟刻度。让我们用方块来表示一个12小时的时钟时间。</p><p>通过<em>GameObject&#x2F;3D Object&#x2F;Cube</em>向场景添加一个立方体对象，将其命名为<em>Hour Indicator 12</em>，同时使其成为Clock的子对象。子对象在层次结构中的顺序并不重要，可以把它放在表盘的上方或下方。</p><p><img src="https://static.huozk.cn/20220814-2b4aaa7060b80fb5c1084ad226427e8d88c7ddaeba9c23a1b851064940aaafcc.png" alt="钟表的子对象-刻度点。 ">  </p><p>将它的比例(Scale)X轴设置为0.5，Y轴设置为1，Z轴设置为0.1，这样它就变成了一个狭长的扁平块。然后设置它的位置(Position)X轴为0，Y轴为4，Z轴为-0.25。这样就会把它放在表盘的上面，在表示刻度12点的位置，同时删除它的<code>BoxCollider</code>组件。</p><p><img src="https://static.huozk.cn/20220814-8071c8b7ace5696a20d6c2e384497d52cad20eba54bfd86709be57ba82033985.png" alt="刻度12点位置显示信息">  </p><p>现在这个刻度标记很难看到，因为它的颜色与表盘相同。让我们通过<em>Assets&#x2F;Create&#x2F;Material</em>，或者通过项目窗口(Project)的加号按钮和鼠标右键菜单，为它创建一个单独的材质。这时我们获得了一个拥有默认材质的材质球资源。更改它的名字为<em>Hour Indicator</em>。</p><p><img src="https://static.huozk.cn/20220814-7a09348e7be79cdd0e5a0878b4c7df880e54664bd416ed3c49d8a489dd76029b.png" alt="项目窗口中的小时指示器，单列和双列布局。">  </p><p>选中该材质球，并通过点击检查面板(Inspector)的颜色字段(Albedo)，将其反照率改为其他的值。这将打开一个颜色弹出窗口，提供各种方式来选择颜色。这里使用了深灰色，对应于十六进制的494949，这与RGB 0-255模式的73相同。我们不使用alpha透明通道，所以它的值不用关注。可以让其他所有属性保持原样。</p><p><img src="https://static.huozk.cn/20220814-b43a9f4fb861c918e9a865e364d18d5ffbc99f66135abe0e8038bde1e54b4434.png" alt="深灰色的反照率。 ">  </p><details>    <summary>什么是反照率？</summary>    <p>反照率是一个拉丁词，意思是白度。它是一个东西被白光照亮时的颜色。</p></details><p>如何让表盘刻度使用这个材质球。你可以通过把材质球拖到场景(Scene)或层次窗口(Hierarchy)中的物体上来实现。也可以在选择游戏对象时把它拖到检查器窗口(Inspector)的底部，或者改变其<code>MeshRenderer</code>的<code>Materials</code>数组中的第0个元素。</p><p><img src="https://static.huozk.cn/20220814-0cf61417acba764869116d2840e0419357deb9b7fc4867f647f73cc48b12f187.png" alt="深灰色刻度信息。"><br>深灰色刻度信息。</p><h2 id="2-4-十二个小时的刻度"><a href="#2-4-十二个小时的刻度" class="headerlink" title="2.4 十二个小时的刻度"></a>2.4 十二个小时的刻度</h2><p>现在我们可以为每个小时都做一个指示刻度。首先，我们要调整场景中摄像机的方向，使我们能够直视Z轴。通过点击场景视图(Scene)右上角的摄像机轴锥来做到这一点。也可以通过网格工具栏上的按钮将场景网格的轴线改为Z轴。</p><p><img src="https://static.huozk.cn/20220814-11ae7e688187bfae0ce5517510890e557337997b2947a67dc57bf8083d6e9386.jpg" alt="沿着Z轴直视时钟。"><br>沿着Z轴直视时钟。</p><p>复制<em>Hour Indicator 12</em>游戏对象。可以通过<em>Edit&#x2F;Duplicate</em>，或通过指定的键盘快捷键Ctrl+D，或通过层次结构窗口(Hierarchy)中的上下文菜单来完成。复制的对象将出现在层次结构窗口(Hierarchy)中原对象的下面，也是时钟的一个子对象。它的名称被设置为<em>Hour Indicator 12 (1)<em>。把它重命名为</em>Hour Indicator 6</em>，对其位置(Position)Y轴设置为相反的值，使其表示小时刻度6。</p><p><img src="https://static.huozk.cn/20220814-dcbbee1771e4faa1c090b93cc55c8def10e5ae68da2a65a3db91e336547c3430.png" alt="小时6和12的指示器信息。"><br>小时6和12的指示器信息。</p><p>用同样的方法创建小时刻度3和9。在这种情况下，它们的(Position)X轴位置应该是4和-4，Y轴位置应该是0。另外将旋转角度(Rotation)Z轴设置为90°，这样它们就转了四分之一圈。</p><p><img src="https://static.huozk.cn/20220814-66ed1e1bcf5dd67a7f3238f641f849bd2ad67bef519eb73b8775127102e849dd.jpg" alt="四个小时刻度。">  </p><p>然后创建另一个小时刻度12的复制体，这次为小时刻度1。 将其位置(Position)X轴设为2，Y轴设为3.464，其旋转角度(Rotation)Z轴设为-30°。然后将其复制到小时刻度2，交换其位置(Position)X轴和Y轴的值，并将其旋转角度(Rotation)Z轴增加至-60°。</p><p><img src="https://static.huozk.cn/20220814-e5ba9c9e9d6a6e3d2342d477eb4576ee9a5efc5ce55fb138ef4698c1e065880a.jpg" alt="第1和第2小时的指示刻度。">  </p><details>    <summary>这些数字是怎么来的？</summary>    每一个小时沿Z轴顺时针旋转30°。在这种情况下，我们使用负旋转，因为Unity的旋转是逆时针的。我们可以通过三角函数找到第一小时的位置。30°的正弦是$\dfrac{1}{2}$，它的余弦是$\dfrac{\sqrt{\smash[b]{3}}}{2}$。 我们用小时刻度与中心的距离来衡量，即4。 因此，我们最终得到$2\sqrt{\smash[b]{3}}\approx3.464$。 则第2个小时指针的旋转角度应该是60°，对此我们可以简单地变换正弦和余弦。</details><p>复制这两个小时刻度并设置它们的位置Y轴和旋转角度为相反的值，接着创建第4和第5小时的刻度对象。然后对第1、2、4、5小时刻度使用同样的技巧来创建其余的刻度对象，这次要设置它们的位置X轴为相反的值，并再次设置相反的旋转角度。</p><p><img src="https://static.huozk.cn/20220814-754a3c2910ea3282e1244ddf08d6830c30bfe88bfa42de2a712efa382ec34f3a.jpg" alt="所有的表盘刻度 1">  </p><h2 id="2-5-创建指针"><a href="#2-5-创建指针" class="headerlink" title="2.5 创建指针"></a>2.5 创建指针</h2><p>下一步是创建时钟的指针。我们从时针开始。再次复制<em>Hour Indicator 12</em>，并将其命名为<em>Hours Arm</em>。然后创建一个时钟的材质，并让时钟使用它。我们把它设置为纯黑色，十六进制的000000。将时针的比例(Scale)X轴降低到0.3，将其Y轴增加到2.5。然后把它的位置Y轴改为0.75，这样它就指向小时刻度12的位置。但也有一点问题，旋转的时候看起来好像手臂有一点配重。</p><p><img src="https://static.huozk.cn/20220814-6b9e8c0cf76c1a06a84d43dac0af1f4aca05239e4581f98b1183ca920b328cf4.png" alt="时针信息。">  </p><p>指针必须围绕时钟的中心旋转，通过改变它的旋转角度(Rotation)Z轴旋转,但是它却围绕自己的中心旋转。</p><p><img src="https://static.huozk.cn/20220814-f62238da498f775095239b577465d4baee2f6afedf64b3faefec22611d51fc4e.gif" alt="时针围绕自己的中心点旋转。">  </p><p>发生这种情况是因为旋转相对于游戏对象的局部位置(Local Position)而言的。为了创建适合的旋转，我们必须引入一个支点对象，代替该对象进行旋转。因此，创建一个新的空游戏对象，并使其成为时钟(Clock)的子对象。你可以通过层次结构窗口(Hierarchy)中时钟的上下文菜单直接创建这个对象。把它命名为<em>Hours Arm Pivot</em>，并确保它的位置和旋转角度是0，比例是1。</p><p><img src="https://static.huozk.cn/20220814-7efafda35ec9c359271ece644b719622ce55dff957ecf9d24c94ea9c8a1b18c6.png" alt="时针与支点。">  </p><p>现在试着旋转这个支点。如果你通过场景视图(Scene)做这个，确保工具手柄的位置模式被设置为枢轴(旋转轴)而不是中心。</p><p><img src="https://static.huozk.cn/20220814-387977e6766ebd133a521cd3a29820ef83f7dd3c50e1f94e0f44ef1d9e0ccad2.gif" alt="时针围绕支点旋转。 ">  </p><p>复制<em>Hours Arm Pivot</em>两次，创建一个<em>Minutes Arm Pivot</em>和<em>Seconds Arm Pivot</em>。对它们进行相应的重命名，包括支点的子对象。</p><p><img src="https://static.huozk.cn/20220814-aa6ad8dc0c67a04c9aa4df92c5bcfd8207fd1de386e27c4ea870de3adb4bda21.png" alt="所有的指针及其支点对象。 ">  </p><p>分钟指针应该比时针更窄更长，所以将其比例(Scale)X轴设置为0.2，Y轴设置为4，然后将其位置(Position)Y轴增加到1。同时将它的Z轴改为-0.35，以便它位于时针的顶部。注意，这是指针，而不是它的父物体支点。</p><p><img src="https://static.huozk.cn/20220814-3f3c2e3ddc3388dcb119304ca1bf6c1f58cf319e99ec10e746def4b644d6fd8d.jpg" alt="分针的位置。 1"> </p><p>也要调整秒针。这次使用0.1和5作为比例(Scale)的XY值，1.25和-0.45作为位置(Position)YZ轴。</p><p><img src="https://static.huozk.cn/20220814-9eace68b672c11d872b93503f160dcbaa2c616d55713c86a1a8cb9f963f639eb.jpg" alt="秒针的位置。">  </p><p>让我们通过为秒针创建一个单独的材质来使其效果突出。我给它设置一个暗红色，十六进制的B30000。另外，我在场景窗口(Scene)中关闭了网格效果，因为已经完成了时钟的制作。</p><p><img src="https://static.huozk.cn/20220814-43ae2a025e0d1462f727178d437f8f8a9a30a36ebaeaaa9a4ebec8d9a1e3daf0.jpg" alt="三条指针的时钟，最终效果。 1">  </p><p>如果你还没有保存，可以通过<em>File&#x2F;Save</em>或指定的键盘快捷方式Ctrl+S保存更改。</p><p>保持项目资源有序性也是一个好习惯。由于我们有三种材质，需要把它们放在一个材质文件夹(Materials)里，通过<em>Assets&#x2F;Create&#x2F;Folder</em>或通过项目窗口(Project)创建。然后你可以把材质拖到那里面。</p><p><img src="https://static.huozk.cn/20220814-ad60ea159890841df4f5677c16febe418cfb21b8c66178c0fddb9d1a23f75470.jpg" alt="项目窗口中材质文件夹。 1">  </p><h1 id="给时钟添加动画效果"><a href="#给时钟添加动画效果" class="headerlink" title="给时钟添加动画效果"></a>给时钟添加动画效果</h1><p>我们的时钟目前不显示时间，它总是停留在十二点钟。为了使它拥有动画效果，必须给它添加一个自定义行为。可以通过创建一个脚本类型文件来实现。</p><h2 id="3-1-C-脚本资源"><a href="#3-1-C-脚本资源" class="headerlink" title="3.1 C#脚本资源"></a>3.1 C#脚本资源</h2><p>通过<em>Assets&#x2F;Create&#x2F;C#创建</em>一个新的脚本资源到项目中，并命名为Clock。C#是用于Unity脚本的编程语言，发音为C-sharp。我们也需要把它放在一个新的Scripts文件夹里，以保持项目的整洁。</p><p><img src="https://static.huozk.cn/20220814-4d546351d91226b63a81580c641ea19d132768e0d3cdb2087637620e528baf09.png" alt="项目窗口中的脚本文件，放在专门的Sceipts文件夹中。 1">  </p><p>当脚本被选中时，检查器窗口(Inspector)将显示其内容。但是要编辑代码，我们就必须使用代码编辑器。你可以通过按检查器中的<em>Open</em>按钮或双击资脚本资源文件打开编辑。使用哪个应用程序编辑脚本可以通过Unity的首选项(Preferences)进行配置。</p><p><img src="https://static.huozk.cn/20220814-d61f03da1a69f44a7ee61f873073d74cc065c25ea8df066cb8e5eb2e727f2177.png" alt="Clock的C#文件显示信息。 1">  </p><h2 id="3-2-定义一个组件类型"><a href="#3-2-定义一个组件类型" class="headerlink" title="3.2 定义一个组件类型"></a>3.2 定义一个组件类型</h2><p>一旦脚本加载到你的代码编辑器中，就可以删除标准模板代码，我们将从头开始创建组件类型。</p><p>一个空的文件没有定义任何东西。它必须包含我们时钟组件的定义。我们要定义的并不是一个组件的单一实例。相反，我们定义的是被称为时钟的一般类或类型。一旦确定了这一点，我们就可以在Unity中创建多个这样的组件，尽管我们在本教程中只限于一个时钟。</p><p>在C#中，我们定义时钟类型时，首先说明我们正在定义一个类，然后是它的名字。<del>在下面的代码片段中，改变后的代码有一个黄色背景，如果你使用深色网页主题查看本教程，则为暗红色。</del>由于我们从一个空文件开始，它的内容应该是字面上的Clock类，而不是其他东西，不过你可以在字与字之间添加空格和换行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Clock</span></span><br></pre></td></tr></table></figure><details>    <summary>技术上讲，什么是类？</summary>    你可以把类看作是一个蓝图，它可以用来创建驻留在计算机内存中的对象。蓝图定义了这些对象包含哪些数据以及它们具有哪些功能。<br>类也可以定义不属于对象实例的数据和功能，而属于类本身。这通常被用来提供全局可用的功能。我们将使用其中的一些功能，但时钟不会有这些功能。</details><p>因为不想限制其他代码可以访问我们的Clock类型，所以需要在它前面加上public访问修饰符。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span></span><br></pre></td></tr></table></figure><details>    <summary>类的默认访问修饰符是什么？</summary>    如果没有访问修饰符，就好像我们写的是内部类Clock。这将限制为可以对同一程序集的代码访问，当你使用打包在不同程序集的代码时，这就变得很重要了。为了确保它总是可访问，默认情况下是让类成为公共的。</details><p>目前，我们还写入有效的C#语法。如果你要保存文件并回到Unity编辑器，那么编译将会出错且将被记录在Unity控制台窗口(Console)。</p><p>现在表示正在定义一个类型，所以我们必须实际定义它是什么样的。这是由声明后面的一个代码块完成的。代码块的边界用大括号表示。现在没有写任何内容，所以只写{}。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们代码现在是有效的。保存文件并切换回Unity。Unity编辑器将检测到脚本资产已经改变，并触发重新编译。完成后，选择我们的脚本。检查器会通知我们，该资源不包含<code>MonoBehaviour</code>脚本。</p><p><img src="https://static.huozk.cn/20220814-68c5af18aceb984dac04e65c5fca5bff941da7b59a532ff31d01f1fd2e32be6e.png" alt="纯C#脚本信息显示">  </p><p>这意味着我们不能用这个脚本在Unity中创建组件(不能挂在到游戏对象上)。在这一点上，我们的时钟定义了一个基本的C#对象类型。我们的自定义组件类型必须扩展Unity的<code>MonoBehaviour</code>类型，继承其数据和功能。</p><details>    <summary>MonoBehaviour是什么意思？</summary>    意思是，我们可以对自己的组件进行编程，为游戏对象添加自定义行为。这就是行为部分所指的内容。它只是碰巧使用了英式拼写，比较老旧。mono部分指的是对自定义代码的支持被添加到Unity的方式。它使用了Mono开源项目，这是一个.NET框架的多平台运行解决方案。因此，<code>MonoBehaviour</code>，这是一个旧的名字，由于向后兼容的原因，我们坚持使用。</details><p>为了把<code>Clock</code>变成<code>MonoBehaviour</code>的一个子类型，我们必须改变我们的类型声明，使其扩展该类型，这可以在我们的类型名称后面加上冒号，然后是它所扩展的内容。这使得<code>Clock</code>继承了<code>MonoBehaviour</code>类的所有类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>然而，这也会导致编译出错。编译器会抱怨找不到<code>MonoBehaviour</code>类型。是因为该类型包含在一个命名空间中，也就是<code>UnityEngine</code>。要访问它，我们必须使用它的全称，<code>UnityEngine.MonoBehaviour</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">UnityEngine.MonoBehaviour</span> &#123;&#125;</span><br></pre></td></tr></table></figure><details>    <summary>什么是命名空间？</summary>    命名空间就像一个网站的域名，但对于代码来说。就像域名可以有子域名，命名空间可以有子命名空间。最大的区别是，它是反过来写的。因此，代替forum.unity.com的将是com.unity.forum。命名空间是用来组织代码和防止命名冲突的。</details><p>包含<code>UnityEngine</code>代码的程序集是与Unity一起的，你不需要单独上网去获取它。如果你导入了合适的编辑器集成包，代码编辑器使用的项目文件应该可以自动识别。</p><p>在访问Unity类型时，总是要包括<code>UnityEngine</code>的前缀，这是很不方便的。幸运的是，我们可以声明命名空间应该被自动搜索以完成C#文件中的类型名称。这可以通过在文件的顶部添加<code>using UnityEngine;</code>来实现。分号需要用来标记语句的结束。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以将我们的自定义组件添加到Unity中的<em>Clock</em>游戏对象中。这可以通过将脚本资源拖到对象上，或者通过对象检查器(Inspector)底部的添加组件按钮来完成。</p><p><img src="https://static.huozk.cn/20220814-652973b91146191463b602820e429cc5243b10c16f200ee46a6e2fd802b87a78.png" alt="三个指针全部拖拽到脚本定义上"></p><p>请注意，我的教程中的大多数代码类型都可以链接到在线文档。例如，<code>MonoBehaviour</code>是一个链接，可以带你到Unity的该类型的在线脚本API页面。</p><h2 id="3-3-获取一个指针"><a href="#3-3-获取一个指针" class="headerlink" title="3.3 获取一个指针"></a>3.3 获取一个指针</h2><p>要旋转指针，Clock对象需要获取它们。让我们从时针开始。像所有的游戏对象一样，它可以通过调整它的Transform组件来旋转。所以我们必须将指针父物体的Transform组件添加到Clock中。这可以通过在它的代码块中添加一个数据字段来完成，定义为一个名称，后面加一个分号。</p><p>时针支点(Hours Pivot)这个名字对这个字段来说是合适的。然而，名称必须是连贯的。惯例是将字段名的第一个词首字母小写，其他词首字母大写(即驼峰命名法)，然后把它们连在一起。最终将它命名为<em>hoursPivot</em>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">hoursPivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>using语句去哪儿了？</summary>    它还在那里，只是上面没有显示出来。代码片段将只包含现在编辑代码，这样你更能知道编辑的内容。</details><p>我们还必须声明字段的类型，在本例中是<code>UnityEngine.Transform</code>。它必须写在字段名的前面。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transform hoursPivot;</span><br></pre></td></tr></table></figure><p>我们的类现在定义了一个字段，它可以持有对另一个对象的引用，其类型必须是<code>Transform</code>。我们必须确保它持有一个对时钟支点的<code>Transform</code>组件的引用。</p><p>字段默认是私有的，这意味着它们只能被属于时钟(Clock)的代码访问。但是这个类不知道我们的Unity场景，所以没有直接的方法来将字段与正确的对象联系起来。我们可以通过将该字段声明为可序列化来改变这种情况。这意味着当Unity保存场景时，它可以被包含在场景的数据中，它是通过把所有的数据放在一个序列中-Serializing-然后把它写到一个文件中。</p><p>将一个字段标记为可序列化是通过给它附加一个属性来完成的，在这里是<code>SerializeField</code>。它被写在字段声明的前面，包括在方括号中，通常在它上面的一行，但也可以放在同一行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot;</span><br></pre></td></tr></table></figure><details>    <summary>我们不能直接把它变成公共的吗？</summary>    是的，但一般来说，使类字段可以公开访问是不好的形式。以往的经验是，只有当其他类型的C#代码需要访问类的内容时，才将其公开，然后优先选择方法或属性而不是字段。越是不能访问的东西就越容易维护，因为可能直接依赖它的代码越少。在本教程中，我们唯一的C#代码是Clock，所以没有理由将其内容公开。</details><p>一旦这个字段是可序列化的，Unity将检测到这一点，并在我们的Clock游戏对象的Clock组件的检查器窗口(Inspector)中显示它。</p><p><img src="https://static.huozk.cn/20220814-66f363bf7f1e035be22cd6e20b8801ef0000ebce553101dc73ae0aad28987ddf.png" alt="时针支点字段显示。">  </p><p>为了连接他们，将<em>Hours Arm Pivot</em>从层次结构(Hierarchy)中拖到<em>Hours Pivot</em>字段上。或者，使用该字段右侧的圆形按钮，在弹出的列表中搜索该时针支点。在这两种情况下，Unity编辑器都会获取<em>Hours Arm Pivot</em>的<code>Transform</code>组件，并将其引用到我们的字段中。</p><p><img src="https://static.huozk.cn/20220814-4d3702519e411884875e00672ddd8cf430fe0de70d535e0c7cb32d019d9984fc.png" alt="连接状态的时针字段。"> </p><h2 id="3-4-获取所有三条指针"><a href="#3-4-获取所有三条指针" class="headerlink" title="3.4 获取所有三条指针"></a>3.4 获取所有三条指针</h2><p>我们必须为分钟和秒臂枢轴做同样的事情。因此，再给Clock添加两个可序列化的Transform字段，并加上适当的名字。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform minutesPivot;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform secondsPivot;</span><br></pre></td></tr></table></figure><p>可以使这些字段声明变得更简洁吗？，因为它们共享相同的属性、访问修饰符和类型。所以可以合并为由逗号分隔开的字段名列表，跟在属性和类型声明后面。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[SerializeField]</span></span><br><span class="line"><span class="comment">//Transform minutesPivot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[SerializeField]</span></span><br><span class="line"><span class="comment">//Transform secondsPivot;</span></span><br></pre></td></tr></table></figure><details>    <summary>//是做什么的？</summary>    双斜线表示一个注释。它们之后直到行尾的所有文本都会被编译器忽略。如果需要的话，它可以用来添加文本以说明代码。我也用它来表示已经被删除的代码。除此之外，被删除的代码有一条线穿过它。</details><p>在编辑器中把另外两个指针支点也挂上。</p><p><img src="https://static.huozk.cn/20220814-51f0e91864bcd62544af15f427a71f5dd0e22fab557ced1d3ee4f8c19af8a758.png" alt="所有三条指针都处于连接状态。">  </p><h2 id="3-5-唤醒"><a href="#3-5-唤醒" class="headerlink" title="3.5 唤醒"></a>3.5 唤醒</h2><p>现在，我们可以访问指针支点了，下一步是旋转它们。要做到这一点，我们需要时钟(Clock)执行一些代码。通过在类中添加一个代码块来完成，也就是所谓的方法。这个代码块的前缀是一个名字，按照惯例，这个名字是大写的。我们将它命名为<code>Awake</code>，说明这些代码应该在脚本被唤醒时执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField］</span></span><br><span class="line"><span class="meta">Transform hoursPivot, minutesPivot, secondsPivot;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">Awake &#123;&#125;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></table></figure><p>方法有点像数学函数，例如$\textit{f}(x) &#x3D; 2x+3$。该函数需要一个数字-由变量参数表示的$x$-将其加倍，然后再加上3。它对一个单一的数字进行操作，其结果也是一个单一的数字。在方法的情况下，它更像$\textit{f}(p)&#x3D;c$是其中$p$代表输入参数，而代表它所执行的任何代码。</p><p>像数学函数一样，方法可以产生一个结果，但这并不是必须的。我们必须声明结果的类型–就像它是一个字段一样，这里通过写成<code>void</code>来表示没有结果。在我们的例子中，我们只是想执行一些代码，而不提供一个结果值，所以使用<code>void</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Awake &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们也不需要任何输入数据。然而，我们仍然要定义方法的参数，作为圆括号之间的逗号分隔的列表。在我们的例子中，它只是一个空列表。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span> ()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们现在有了一个有效的方法，尽管它还没有做任何事情。就像Unity检测到我们的字段一样，它也检测到了这个<code>Awake</code>方法。当一个组件有一个<code>Awake</code>方法时，Unity会在该组件被唤醒时调用该方法。这发生在它被创建或在游戏模式下被加载之后。我们目前处于编辑模式，所以这还没有发生。</p><details>    <summary>Awake不是必须是公共的吗？</summary>    Awake和其他一些方法被认为是特殊的Unity事件方法。不管我们如何声明它们，Unity引擎会找到它们并在适当的时候调用它们。这发生在托管的.NET环境之外。详细内容可以查阅Unity脚本生命周期。</details><p>请注意，<code>Awake</code>和其他特殊的Unity事件方法在<del>我的教程中有粗体字</del>，并链接到其在线Unity脚本API页面。</p><h2 id="3-6-通过代码进行旋转"><a href="#3-6-通过代码进行旋转" class="headerlink" title="3.6 通过代码进行旋转"></a>3.6 通过代码进行旋转</h2><p>为了旋转指针，我们必须创建一个新的旋转角度。我们可以通过给<code>Transform</code>的<code>localRotation</code>属性分配一个新的旋转角度来旋转它。</p><details>    <summary>什么是属性？</summary>    属性是一种方法，它假装是一个字段。它可能是只读或只写的。C#的惯例是将属性大写，但Unity的代码并没有这样做。</details><p>虽然<code>Transform</code>组件的旋转角度在检查器(Inspector)中是用欧拉角(Euler)定义的，单位是每轴度数，但在代码中我们必须用四元数(Quaternion)来设置。</p><details>    <summary>什么是四元数？</summary>    四元数是基于复数的，用来表示三维旋转。虽然比单独的X、Y和Z旋转角的组合更难理解，但它们有一些有用的特性。例如，它们不会受到万向节锁的影响。</details><p>通过调用<code>Quaternion.Euler</code>方法创建一个基于欧拉角的四元数。具体做法是在<code>Awake</code>中写入，然后用分号来结束语句。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">Quaternion.Euler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法有用于描述所需旋转的参数。在这种情况下，我们将提供一个逗号分隔的包含三个参数的列表，都在圆括号之间，在方法名称之后。我们为X、Y和Z的旋转轴提供三个数值。前两个使用0，Z旋转角度使用-30。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-30</span>);</span><br></pre></td></tr></table></figure><p>这个调用的结果是一个四元数结构值，包含围绕Z轴的30°顺时针旋转，与我们时钟上的小时数相匹配。</p><details>    <summary>什么是结构？</summary>    结构是结构体的简称，是一种蓝图，就像一个类。不同的是，无论它创建的是什么，都被视为一个简单的值，如整数或颜色，而不是一个对象。它没有身份感。定义自己的结构与定义类的工作原理相同，只是你写的是结构而不是类。</details><p>为了将这个旋转应用于时针，使用&#x3D;赋值语句将<code>Quaternion.Euler</code>的结果分配给<code>hoursPivots.localRotation</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-30</span>);</span><br></pre></td></tr></table></figure><details>    <summary>localRotation和Rotation之间有什么区别？</summary>    <code>localRotation</code>属性表示<code>Transform</code>组件单独描述的旋转，因此它是一个相对于其父级的旋转角度。这是你在其检查器(Inspector)中看到的旋转角度。相比之下，<code>Rotation</code>属性表示世界空间中的最终旋转角度，将整个对象的层次结构都考虑在内。如果我们将时钟作为一个整体进行旋转，设置该属性会产生奇怪的结果。因为该属性在对时钟的旋转角度进行补偿时，指针会忽略这一点。</details><details>    <summary>难道不应该有一个警告说hoursPivot从未被初始化吗？</summary>    编译器可以检测到没有任何代码为该字段赋值，确实可以发出这样的警告，因为它不知道我们通过Unity的检查器(Inspector)设置了它。然而，这个警告在默认情况下是被关闭。可以通过项目设置(Project Settings)来控制开关。在<em>Player/Other Settings/Script Compilation</em>下有一个抑制普通警告的切换键。它关闭了关于未初始化和未使用的私有字段的警告。</details><p>现在编辑器中进入播放模式。你可以通过 <em>Edit&#x2F;Play，</em> 指定的键盘快捷键或按编辑器窗口顶部中间的播放按钮来实现。Unity将把焦点切换到游戏窗口(Game)，它将渲染场景中主摄像机看到的所有东西。时钟(Clock)组件将被唤醒，时钟(Clock)将被设置为一点钟状态。</p><p><img src="https://static.huozk.cn/20220814-f49558a4f07eecf9b16ec8fd985831e2fb69035094b69b916fb7f594f1f6b80c.jpg" alt="播放模式下，总是保持在1点钟状态。">  </p><p>如果摄像机没有聚焦在时钟上，你可以移动它使时钟变得可见，但请记住，当退出游戏模式时，场景会被重置，所以你在游戏模式(Play)中对场景所做的任何改变都不会持续。但对资源来说不是这样的，它们的改变总是会被保存的。你也可以在游戏模式(Play)中打开场景窗口(Scene)，甚至是多个场景(Scene)和游戏窗口(Play)。在继续之前退出游戏模式(Play)。</p><h2 id="3-7-获取当前的时间"><a href="#3-7-获取当前的时间" class="headerlink" title="3.7 获取当前的时间"></a>3.7 获取当前的时间</h2><p>下一步是弄清我们醒来时的当前时间。我们可以使用<code>DateTime</code>结构来访问我们正在运行的设备的系统时间。<code>DateTime</code>并不是一个统一的类型，它可以在<code>System</code>命名空间中找到。它是.NET框架核心功能的一部分，Unity就是用它来支持脚本的。</p><p><code>DateTime</code>有一个<code>Now</code>属性，产生一个包含当前系统日期和时间的<code>DateTime</code>值。为了检查它是否正确，我们将在<code>Awake</code>开始时，通过把它传递给<code>Debug.Log</code>方法来实现把它记录到控制台(Control)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">Debug.Log(DateTime.Now);</span><br><span class="line">hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们每次进入播放模式都会得到一个时间戳的记录。你可以在控制台窗口(Control)和编辑器窗口底部的状态栏中看到它。</p><h2 id="3-8-转动指针"><a href="#3-8-转动指针" class="headerlink" title="3.8 转动指针"></a>3.8 转动指针</h2><p>我们越来越接近一个可以工作的时钟了。让我们再次从小时开始。<code>DateTime</code>有一个<code>Hour</code>属性，可以获得<code>DateTime</code>值的小时部分。在当前的时间戳上调用这个属性，我们就可以得到当前的小时时间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(DateTime.Now.Hour);</span><br></pre></td></tr></table></figure><p>因此，为了让时针显示出当前的小时，我们必须将-30°的旋转角度值乘以当前的小时。乘法是用星号*字符完成的。我们也不再需要记录当前时间，现在可以去掉这个语句。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="comment">//Debug.Log(DateTime.Now.Hour);~~</span></span><br><span class="line">hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-30</span> * DateTime.Now.Hour);</span><br></pre></td></tr></table></figure><p><img src="https://static.huozk.cn/20220814-29154618857e1bbba5f2f0ba25238d0fad46387a784be121c082f384b0128f84.jpg" alt="播放模式下，时针指定的方向，由于我是零点设置的，所以跟原来一样的效果。 1">  </p><p>为了明确我们是从小时时间到角度的转换，我们可以定义一个包含转换系数的<code>hoursToDegrees</code>字段。<code>Quaternion.Euler</code>的角度被定义为浮点值，所以我们将使用浮点类型。我们已经知道了这个数字，可以立即把它作为字段声明的一部分。然后与<code>DateTime</code>中的值字段相乘，而不是与<code>Awake</code>中的字面数字<code>-30</code>相乘。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> hoursToDegrees = <span class="number">-30</span>。</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>什么是浮点数？</summary>    计算机不能存储所有的数字，它们必须可以在其二进制存储器中被表示，而二进制存储器是由不是0就是1的比特组成，这使得许多数字不可能在有限的内存大小内精确地存储；例如$\dfrac{1}{3}$，就像我们不能精确地用十进制符号来写这个数字一样。我们能做的最好的事情就是写0.3333333，然后在某个点上停止。<br>    假设我们决定在点的后面最多写三位数，而在点的前面只写一位数。那么$\dfrac{1}{3}$就近似于0.333。如果我们要用$\dfrac{1}{3}$除以100，那么我们就会被迫写成0.003，这意味着我们失去了两位数的精度。为了提高小数值的精度，让我们添加一个单独的指数，表示我们数字的数量级。那么$0.333\times10^{-2}$可以表示$\dfrac{1}{3}$除以100，而不会失去有意义的数字。而且我们可以用$0.333\times10^{2}$来表示100的乘法，同时在点的前面只保留一个数字。因此，点可以被认为是浮动的，因为它并不指定一个固定的数量级。这使得我们可以只用几个数字来表示大量的数字。<br>    浮点数在计算机中的工作原理是一样的，只是它们使用二进制而不是十进制的数字，而且还必须表示一些特殊的数值，如无穷大和非数字。一个浮点数就是这样一个存储在四个字节中的值，这意味着它有32位。</details><p>如果我们声明一个没有后缀的整数，那么它被认为是一个整数，这是一个不同的值类型。尽管编译器会自动进行转换，但让我们通过给它们加上f后缀来明确说明我们所有的数字都是float类型的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">hoursPivot.localRotation = </span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每小时的度数总是相同的。我们可以通过在<code>hoursToDegrees</code>的声明中加入<code>const</code>前缀来执行这一点。这将它变成一个常量而不是一个字段。</p><details>    <summary>const值有什么特殊之处？</summary>    const关键字表示一个值永远不会改变，不需要成为一个字段。相反，它的值将在编译过程中被计算出来，并被替换为常量的所有用法。这只适用于像数字这样的原始类型。</details><p>让我们使用<code>DateTime</code>的适当属性，对另外两个指针进行同样的处理。一分钟和一秒钟都用负六度的旋转来表示。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hoursToDegrees = <span class="number">-30f</span>, minutesToDegrees = <span class="number">-6f</span>, secondsToDegrees = <span class="number">-6f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * DateTime.Now.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * DateTime.Now.Second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://static.huozk.cn/20220814-ec4d63a7c396d582136103b9350c0a91a95013a848485fae8499b3bc9dea04f5.jpg" alt="根据当前时间显示指针">  </p><p>我们使用了三次<code>DateTime.Now</code>，来检索小时、分钟和秒。每一次我们都要重新访问这个属性，这需要一些间隔，理论上可能会导致不同的时间值。为了确保这种情况不会发生，我们应该只检索一次时间。可以通过在方法内部声明一个变量并将时间赋值给它，然后在之后使用这个值来做到这一点。让我们把它命名为<code>time</code>。</p><details>    <summary>什么是变量？</summary>    变量的作用类似于字段，只不过它只在方法执行时存在。它属于这个方法，而不是属于这个类。</details><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">DateTime time = DateTime.Now;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.Second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在变量的情况下，可以省略类型声明，用<code>var</code>关键字来代替。这可以缩短代码，但只有当变量的类型可以从声明时分配给它的内容中推断出来时才可以使用。另外，我倾向于只在语句中明确提到类型时才这样做，这里就属于这种情况。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = DateTime.Now;</span><br></pre></td></tr></table></figure><h2 id="3-9-给指针做动画"><a href="#3-9-给指针做动画" class="headerlink" title="3.9 给指针做动画"></a>3.9 给指针做动画</h2><p>当我们进入播放模式时会得到了当前的时间，但之后，时钟仍然保持不动。为了保持时钟与当前时间的同步，将我们的<code>Awake</code>方法的名字改为<code>Update</code>。这是另一个特殊的事件方法，只要我们保持在游戏模式中，每一帧都会被Unity调用，而不是只调用一次。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line"><span class="keyword">var</span> time = DateTime.Now;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.Second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://static.huozk.cn/20220814-1092f9e5eda796a113b0355e5d93fd2ccde8dc6ef40dae4a1a92f16656acf6d3.gif" alt="不连贯时针动画">  </p><details>    <summary>什么是一帧？</summary>    在游戏模式下，Unity不断地从主摄像机的视角渲染场景。一旦渲染完成，结果就会呈现在显示屏上。然后显示器将显示该帧，直到得到下一帧。在渲染新的一帧之前，一切都会被更新。所以Unity经历了一个更新、渲染、更新、渲染等的序列。通常情况下，一个单一的更新步骤和渲染一次场景被认为是一个单一的帧，尽管在现实中，时间是比较复杂的。</details><p>请注意，我们的时钟组件在检查器(Inspector)中的名字前面有一个切换按钮。这允许我们禁用它，可以防止Unity调用其更新方法。</p><p><img src="https://static.huozk.cn/20220814-ba36c650471fd0a12daa3f26fd9404a1ae2b3904bc4435def84bd2575ce3e53e.png" alt="可以通过按钮暂停脚本使用">  </p><h2 id="3-10-持续旋转"><a href="#3-10-持续旋转" class="headerlink" title="3.10 持续旋转"></a>3.10 持续旋转</h2><p>我们的时钟指针准确地表明了当前的小时、分钟和秒。它的行为就像一个数字钟，离散的，但有指针。通常情况下，通过提供时间的模拟表示，时钟有缓慢连续旋转的指针。让我们修改我们的方法，使时钟成为真实模拟状态。</p><p><code>DateTime</code>不包含小数点数据。幸运的是，它确实有一个<code>TimeOfDay</code>属性。这给了我们一个<code>TimeSpan</code>值，它包含了我们需要格式的数据，通过它的<code>TotalHours, TotalMinutes, 和TotalSeconds</code>属性。</p><p>首先，从<code>DateTime.Now</code>中获取<code>TimeOfDay</code>结构值，并将其存储在变量中。由于该语句中没有提到<code>TimeSpan</code>的类型，我将使变量的类型更明确。然后调整我们用来旋转指针的属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">TimeSpan time = DateTime.Now.TimeOfDay;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.TotalHours);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.TotalMinutes);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.TotalSeconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将导致编译器错误，告知我们不能从双数转换为浮点数。发生这种情况是因为<code>TimeSpan</code>属性产生的值是双精度浮点类型，即所谓的<code>double</code>。这些值提供了比浮点值更高的精度，但是Unity的代码只适用于单精度的浮点值。</p><details>    <summary>单精度够吗？</summary>    对于大多数游戏来说，是的。当处理非常大的距离或比例差异时，这就成为一个问题。那么你就必须使用一些技巧，比如传输或对于相机的渲染来保持活动区域在世界原点附近。虽然使用双精度可以解决这个问题，但它也会使所涉及的数字的内存大小增加一倍，从而导致其他性能问题。游戏引擎通常使用单精度浮点值，而GPU也是如此。</details><p>我们可以通过强制地将双数转换为浮点数来解决这个问题。这个过程被称为转换，通过在要转换的值前面的圆括号中写上新的类型来完成。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * (<span class="built_in">float</span>)time.TotalHours);</span><br><span class="line"></span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * (<span class="built_in">float</span>)time.TotalMinutes);</span><br><span class="line"></span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * (<span class="built_in">float</span>)time.TotalSeconds);</span><br></pre></td></tr></table></figure><p><img src="https://static.huozk.cn/20220814-f97ced0a10c8c397c2d393016a2749eb2aea30e1969eeed3bed5f8b5d3f5387a.gif" alt="最终效果">  </p><p>现在你知道了在Unity中创建对象和编写代码的基本原理。下一个教程是建立一个图形(Graph)。</p><blockquote><p>源码仓库地址：<a href="https://github.com/huozk0804/UnityTutorialsOfBasics">https://github.com/huozk0804/UnityTutorialsOfBasics</a><br>该文章原文地址：<a href="https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/">https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/</a><br>授权文件：<a href="https://huozk.cn/2022/08/cd3d674a/">https://huozk.cn/2022/08/cd3d674a/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用简单的对象构建一个时钟。&lt;/p&gt;
&lt;p&gt;写一个C#脚本。&lt;/p&gt;
&lt;p&gt;转动时钟的指针以显示时间。&lt;/p&gt;
&lt;p&gt;对钟臂进行动画处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是关于学习使用Unity基础知识的系列教程中的第一个教程。在本教程中，我们将创建一个简单的时钟，并对脚本组件进行编程，让它显示当前时间。你不需要有任何使用Unity编辑器的经验，但需要你有一些使用多窗口编辑器应用程序的经验。&lt;/p&gt;
&lt;p&gt;在我所有教程的底部，你可以找到教程许可证的链接，包含完成的教程项目的资源库，以及教程页面的PDF版本。&lt;/p&gt;
&lt;p&gt;本教程是用Unity 2020.3.6f1制作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.huozk.cn/20220814-4585c7a8fa39ec03fbfc78ffaccc5b41555bc348a1e5f61f605b11e12c84ccca.jpg&quot; alt=&quot;这是时钟的最终效果&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Creating-a-Project&quot;&gt;&lt;a href=&quot;#Creating-a-Project&quot; class=&quot;headerlink&quot; title=&quot;Creating a Project&quot;&gt;&lt;/a&gt;Creating a Project&lt;/h1&gt;&lt;p&gt;在开始使用Unity编辑器之前，我们必须首先创建一个项目。&lt;/p&gt;
&lt;h2 id=&quot;1-1-新项目&quot;&gt;&lt;a href=&quot;#1-1-新项目&quot; class=&quot;headerlink&quot; title=&quot;1.1 新项目&quot;&gt;&lt;/a&gt;1.1 新项目&lt;/h2&gt;&lt;p&gt;当你打开Unity时，你会看到Unity Hub。这是一个启动器和安装程序，在这里你可以创建或打开项目，以及安装管理Unity版本，并做一些其他事情。如果你没有安装Unity2020.3或更高版本，现在就请添加它吧。&lt;/p&gt;
&lt;details&gt;
    &lt;summary&gt;哪些Unity版本是合适的？&lt;/summary&gt;
    &lt;p&gt;Unity每年会发布很多个新版本。其中有两个平行版本发布时间表。最稳定和安全的是LTS版本。LTS代表长期支持，在Unity说明下是支持两年。&lt;/p&gt;
    &lt;p&gt;我的教程坚持使用LTS版本，其中2020.3是最新版本。本教程特别使用2020.3.6。版本号的第三部分表示补丁版本。补丁版本包含错误修复，很少有新功能。另一个f1后缀表示官方最终版本。任何2020.3版本都可以用于本教程。&lt;/p&gt;
&lt;/details&gt;</summary>
    
    
    
    <category term="Catlike Coding Unity Tutorial" scheme="http://huozk.cn/categories/Catlike-Coding-Unity-Tutorial/"/>
    
    
    <category term="unity-base" scheme="http://huozk.cn/tags/unity-base/"/>
    
  </entry>
  
  <entry>
    <title>Catlike Coding Unity Tutorial License</title>
    <link href="http://huozk.cn/2022/06/catlike-coding-unity-tutorial-license/"/>
    <id>http://huozk.cn/2022/06/catlike-coding-unity-tutorial-license/</id>
    <published>2022-06-15T01:46:42.000Z</published>
    <updated>2023-05-25T11:14:10.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unity-Tutorial-License"><a href="#Unity-Tutorial-License" class="headerlink" title="Unity Tutorial License"></a>Unity Tutorial License</h2><blockquote><p>基于MIT-0和CC BY-NC-SA 4.0。</p></blockquote><p>所有Catlike Coding Unity教程都有两个许可证，一个是代码和资产的许可证，另一个是教程本身的许可证。</p><h2 id="代码和资源许可证"><a href="#代码和资源许可证" class="headerlink" title="代码和资源许可证"></a>代码和资源许可证</h2><p>下面的MIT-0许可证适用于所有代码、纹理和其他Unity项目文件，作为教程的一部分提供。它使用MIT许可证，没有归属权。这意味着你可以不受限制地使用这些内容。你不需要在你的项目中引用一个许可证文件。你也不必把这些归功于我，但如果你想这样做，我肯定会很感激。</p><h3 id="1-1-MIT无署名-MIT-0"><a href="#1-1-MIT无署名-MIT-0" class="headerlink" title="1.1 MIT无署名(MIT-0)"></a>1.1 MIT无署名(MIT-0)</h3><p>Copyright 2022 Jasper Flick</p><p>特此允许任何获得本软件和相关文档文件（”软件”）副本的人无限制地处理本软件，包括但不限于拥有使用、复制、修改、合并、出版、分发、许可或销售本软件副本的权利，以及允许使用本软件的人也这样做。</p><p>声明：本软件 “按原样 “提供，没有任何明示或暗示的保证，包括但不限于对适销性、特定用途的适用性和非侵权性的保证。在任何情况下，作者或版权持有人都不对，无论是在合同、侵权行为或其他诉讼中，由本软件或本软件的使用及其他交易引起的与之相关造成的任何索赔、损害或其他责任负责。</p><h3 id="1-2-给予信用"><a href="#1-2-给予信用" class="headerlink" title="1.2 给予信用"></a>1.2 给予信用</h3><p>如果你想在你的作品中引用我的名字，你可以通过提及我Jasper Flick或Catlike Coding来实现。如果你想在你的作品中提到我Jasper Flick或<a href="https://catlikecoding.com/">Catlike Coding</a>的话，可以提供本网站的链接。</p><h2 id="教程许可"><a href="#教程许可" class="headerlink" title="教程许可"></a>教程许可</h2><p>署名-非商业性-相同方式共享4.0国际（CC BY-NC-SA 4.0）许可证适用于我所有的教程。我指的是实际的教程，而不是它们演示的内容。它涵盖了文字、截图、图表、动画、PDF和其他媒体，这些共同构成了一个教程。它不适用于代码和资产，但它确实适用于表现形式：添加和删除的风格等等。</p><h3 id="2-1-翻译我的教程"><a href="#2-1-翻译我的教程" class="headerlink" title="2.1 翻译我的教程"></a>2.1 翻译我的教程</h3><p>只要你遵守上述的CC BY-NC-SA 4.0许可证，你可以翻译我的作品并将其存放在任何地方。但是我不能为翻译的质量作担保。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Unity-Tutorial-License&quot;&gt;&lt;a href=&quot;#Unity-Tutorial-License&quot; class=&quot;headerlink&quot; title=&quot;Unity Tutorial License&quot;&gt;&lt;/a&gt;Unity Tutorial License&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;基于MIT-0和CC BY-NC-SA 4.0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有Catlike Coding Unity教程都有两个许可证，一个是代码和资产的许可证，另一个是教程本身的许可证。&lt;/p&gt;
&lt;h2 id=&quot;代码和资源许可证&quot;&gt;&lt;a href=&quot;#代码和资源许可证&quot; class=&quot;headerlink&quot; title=&quot;代码和资源许可证&quot;&gt;&lt;/a&gt;代码和资源许可证&lt;/h2&gt;&lt;p&gt;下面的MIT-0许可证适用于所有代码、纹理和其他Unity项目文件，作为教程的一部分提供。它使用MIT许可证，没有归属权。这意味着你可以不受限制地使用这些内容。你不需要在你的项目中引用一个许可证文件。你也不必把这些归功于我，但如果你想这样做，我肯定会很感激。&lt;/p&gt;
&lt;h3 id=&quot;1-1-MIT无署名-MIT-0&quot;&gt;&lt;a href=&quot;#1-1-MIT无署名-MIT-0&quot; class=&quot;headerlink&quot; title=&quot;1.1 MIT无署名(MIT-0)&quot;&gt;&lt;/a&gt;1.1 MIT无署名(MIT-0)&lt;/h3&gt;&lt;p&gt;Copyright 2022 Jasper Flick&lt;/p&gt;
&lt;p&gt;特此允许任何获得本软件和相关文档文件（”软件”）副本的人无限制地处理本软件，包括但不限于拥有使用、复制、修改、合并、出版、分发、许可或销售本软件副本的权利，以及允许使用本软件的人也这样做。&lt;/p&gt;
&lt;p&gt;声明：本软件 “按原样 “提供，没有任何明示或暗示的保证，包括但不限于对适销性、特定用途的适用性和非侵权性的保证。在任何情况下，作者或版权持有人都不对，无论是在合同、侵权行为或其他诉讼中，由本软件或本软件的使用及其他交易引起的与之相关造成的任何索赔、损害或其他责任负责。&lt;/p&gt;
&lt;h3 id=&quot;1-2-给予信用&quot;&gt;&lt;a href=&quot;#1-2-给予信用&quot; class=&quot;headerlink&quot; title=&quot;1.2 给予信用&quot;&gt;&lt;/a&gt;1.2 给予信用&lt;/h3&gt;</summary>
    
    
    
    <category term="Catlike Coding Unity Tutorial" scheme="http://huozk.cn/categories/Catlike-Coding-Unity-Tutorial/"/>
    
    
  </entry>
  
  <entry>
    <title>[转]是谁谋杀了我们的游戏？</title>
    <link href="http://huozk.cn/2022/01/symptoms-of-game/"/>
    <id>http://huozk.cn/2022/01/symptoms-of-game/</id>
    <published>2022-01-15T02:50:09.000Z</published>
    <updated>2023-05-25T11:18:36.660Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Yocar, 腾讯《斗战神》项目主策划</p></blockquote><h2 id="失败！继续下一个失败！"><a href="#失败！继续下一个失败！" class="headerlink" title="失败！继续下一个失败！"></a>失败！继续下一个失败！</h2><p>就在此时，大量的游戏研发团队正在走向失败，闭上眼睛想象一下这个画面，然后睁开眼睛看看周围。它正发生在你的身边吗？</p><p>在2006年，国内有超过60款自主研发的网络游戏面世，最后活下来的并能够盈利的，不超过15款。不用怀疑这一点：超过75％的项目都直接失败了或远未达到预期！在竞争日益激烈的中国网游市场中，这个比例甚至还在提高。大盘大盘新出炉还冒着热气的游戏，等不到大规模宣传，就在各种级别的内部测试中无声无息地被倒进了泔水桶。剩下的呢？你试图回忆上个月在17173上大张旗鼓宣布公测万人空巷的国产巨作叫什么名字，却怎么也记不起来。旱花一现，用来形容今天的大部分新网游，毫不过分。</p><p>到底出了什么错？</p><p>是谁谋杀了我们的游戏？</p><p>为什么抬眼四望，到处只见血淋淋的成品？</p><p>四年前“一边睡觉一边印钞”的黄金产业消失了？</p><p>可爱的玩家怎么突然都变得这么始乱终弃面目狰狞？</p><p>本文并非要分析外部环境，市场竞争，文化积累，用户心理，游戏内容或者各种人品问题，而只是想从游戏开发者内部一个小小方面——也就是我所从事的游戏策划的角度，来看待游戏自主研发的失败原因。本文不是有关如何做好一个策划的指南，只是较为感性地表达作者个人的观点，并列举与此相关的实际教训，希望对那些还没有彻底失败的项目有所警示。</p><h2 id="死婴"><a href="#死婴" class="headerlink" title="死婴"></a>死婴</h2><p>十月怀胎，胎死腹中。</p><p>这样的说法有点残忍，但如果你也在某个最后不得不以解散告终的游戏项目组里呆过，应该明白这个比喻恰如其分。不少游戏都呈现出这种惊人的相似性：研发一年左右，然后在大部分玩家见到之前迅速挂掉。这和投资商的急功近利有关，也可以和决策失误，混乱的管理，市场口味变换，团队经验缺乏，或印尼海啸都扯上一点关系，可是我们无法确定最根本的原因：是精子活力不强么？是怀的时间不够长么？是营养跟不上么？是负责剖腹产手术的医生水平低劣么？为什么我们总是不能顺利生产出健康的宝宝（产品）呢？</p><p>成功的游戏往往被人忽视的一点是：它们之所以活下来，并不是因为它们比多数死掉的同胞消耗了更多的资源，花费了更久的时间。人们总是喜欢不自觉地夸大游戏（或者其他产品）研发过程中“精英化”“勤奋”和“拖延”的成分，他们举出很多例子，如“程序们彻夜讨论物理引擎的改良”“美术使用256色调色板反复尝试终于调出逼真的尾焰”“策划否决了近30种不同的BOSS方案”“经理拼命说服董事会再次推迟发行一年”等等来证实这些观点。</p><p>事实真的是这样吗？</p><p>不可否认，工作态度和外部环境都对最后的成功起着关键性的作用，但如果大家的注意力都放在慢工出细活，十年磨一剑的少数伟大作品上时，就会形成了一种回避，一种对自身进行全方位检讨的回避。这样做的结果，是导致出现了一个如何做好游戏的“大方法论”，把做游戏看成命题作文，公司里所有有关如何做好的讨论，都演变成如何更接近这个“大方法论”的研讨会。在我看来，这种对成功者千篇一律的单一诠释，实在是居心叵测，它一定程度抵消了对游戏制作者自身根本素质的质疑，而没有质疑，更不会有反省和改善。</p><p>回到现实，看看市场上那些正在大赚其钱的那些游戏都是抄袭哪个统一模版生产出来的。《街头篮球》是一个很好的例子，这个游戏是在一年内创造的杰作，一个没有太多经验的团队（他们的第一款作品甚至失败了）仓卒中完成了它，后来它成了市场占有率最高的体育类网络游戏。这足以提醒我们去寻找一些和“杰出领袖+精英齐聚+多年心血”不一样的东西，一些有关游戏人本身相关的东西。</p><p>好吧，让我们回忆一下，在最后令人悲痛万分的难产发生之前，策划都干过些什么事情。</p><h2 id="被诅咒的团队"><a href="#被诅咒的团队" class="headerlink" title="被诅咒的团队"></a>被诅咒的团队</h2><p>我总在怀疑，是不是一部分失败的项目，一开始就输在了起跑线上？如果把这个问题集中到游戏策划一个点上，不难发现，有些东西，从一个游戏的酝酿之初就在某些人脑中萌芽了，可以把它描述为一种越来越强烈心理暗示——</p><p>“我是如此深刻地洞察了它的固有缺陷，我已经预感到了它最后的必然失败。”</p><p>一旦你们的策划也这样想，很不幸，这个团队被这无敌的谶言给诅咒了。</p><p>请再次展开你的记忆，这次的场景里包含很多个屏幕——没错，是闲暇时同事们五颜六色的显示器，在你脑中应该很快可以浮现出一些画面：重叠的聊天窗口，18禁的图片，新的美剧，Blizzard或者valve的陈年旧作……</p><p>你看到项目组正在测试的那款游戏了么？没有。</p><p>下次再留心一下，如果情况真的是这样，这便是被诅咒后最典型的表现。</p><p>为什么不玩你自己的游戏？</p><p>“为什么不玩玩咱们自己的游戏？”</p><p>挨个去问你的同事这个问题。大部分人可能会嘲笑你，不屑于回答；也可能有人老实一点告诉你：“有什么好玩的，天天工作就是干这个，还不腻么？”如果这话是出自程序和美术之口，你可以无视，他们即使不怎么爱玩自己的游戏，也一样可以把本职工作做好，只是不够卓越而已。但如果类似的回答来自项目的策划，创意总监，策划主管之类的人，那么很不幸，也许最糟糕的情况发生了：</p><p>项目的策划，尤其是主策划不热衷玩自己的游戏，是游戏研发中极端危险的征兆。</p><p>这个说法有老生常谈之嫌，很像“你做的游戏自己都不喜欢，更不用指望别人”的翻版，不过对于策划而言，我认为这个经验值得被经常提起。因为更常见的情况是，大家早对此视而不见了。</p><blockquote><p>💬 我之前所在的公司曾开发过一个有趣的小型消除类游戏。几乎所有人，不只是开发人员，都在这个游戏测试期成了它的忠实玩家，我们在下班后兴致勃勃地组队进行比赛，为游戏中的胜利和新的等级头衔得意洋洋。我当时负责它的音效部分，为此我制作了3套不同的音效换着体验，包括一套黑人RAP风格的音效，仅仅是自己为了好玩。这个游戏正式&gt; 上线后，它的在线人数很快超过了我们的预期。<br>—— yocar</p></blockquote><p>请记住两件事情：</p><p>第一，热衷不是喜欢。没有任何人会强迫你喜欢某样东西，总有一些人不喜欢自己的想法变成现实。问题是，如果策划连为自己游戏投入大量业余时间的耐性都没有的话（这就叫热衷），他如何能发现这个游戏真正的可玩性所在呢？他如何理解那些为这个游戏乐此不疲的玩家呢？他如何知道下一步该做什么才会让用户满意呢？</p><p>第二，一个好的游戏是任何时候都值得玩的。如果如果策划用“玩伤了”作为理由来搪塞，他等于是在说，我已经放弃了，我看不到它还有任何可以让我兴奋的地方（虽然我没怎么玩它），天哪！别让我继续体验这个烂东西了，我天天都在伤脑筋，难道还不比你清楚？它没有办法改进了，一点也没有！</p><p>认真想一想，不觉得崩溃么？当项目组最核心的成员，那些专职负责思考游戏性，不断发掘游戏新乐趣，制定游戏未来开发方向的“先知”们，在项目还根本没有失败的时候，竟似乎获得了神启，看到了未来自己作品的惨淡收场，然后为此感到无可救药的沮丧，决定不再碰自己的游戏，不仅不碰，甚至开始憎恨它为自己带来了那么多的挫败感。这好比士兵们还对战争的前景抱有希望的时候，指挥官们竟在悄悄准备着缴械投降，还有什么这更糟的吗？</p><blockquote><p>💬 在一次对组内成员玩自己游戏情况的观察中，我注意到策划的游戏平均等级并不比程序和美术更高。得分最多的一&gt; 位策划拥有的角色经验值，击杀数和游戏局数，均不到得分最多的一位客户端程序的1&#x2F;5。而美术里得分最多的那个人，他的游戏分数大约相当于所有策划的分数之和。<br>—— yocar</p></blockquote><p>另一个可怕的事实是，多数策划以为这种情绪不会被人察觉——没错，看上去他们一直在加班，对每项工作细致跟进，跑来跑去积极进行多方沟通，和其他人开着毫无幽默感的玩笑。可是真相往往就是这么简单和难堪：</p><p>他们真的，真的很少在玩自己的游戏。</p><p>所以不用再遮遮掩掩了，当策划对自己所在的游戏项目流露出悲观时，这种态度就会像春雨一样潜入所有人的心田，迅速在整个团队蔓延。哪怕是最迟钝的成员，也会很快被这种情绪感染，然后你将看到前文所说的情况：越来越少的同事在玩这个游戏了。</p><p>消极的策划对团队的破坏力就是这样巨大，他们对团队带来的绝望是如此深刻。他们本该是一群最有动力，热情和主动性的人，但现在最主动的工作却变成环境所迫的被动行为；他们本是推动变革的领袖，他们却失去了最起码的胆量；他们不再愿意去探索这个游戏还有什么可玩之处，他们惧怕任何大的改变；他们没有野心，没有信心，更不用提为“我们的宝宝”规划远景和绘制蓝图；他们会把每个阶段的失败推诿到各种“正确的原因”上，但绝不会提及自己是如何毁灭了一个游戏开发团队的精神根基——我们在做好玩的游戏。</p><p>如果你留意看过他们的眼睛，也许就明白了这一切，那是一潭死水，里面根本看不到理想主义的灼灼火焰。</p><p>离策划越近，离玩家越远</p><h2 id="要不要把玩家当牲口看？"><a href="#要不要把玩家当牲口看？" class="headerlink" title="要不要把玩家当牲口看？"></a>要不要把玩家当牲口看？</h2><p>别被吓着，在国内（网络游戏）策划圈内，类似这种主题的讨论司空见惯，毫不夸张。如果硬要换个温和点的说法，可以描述为：狗日的网络游戏产业，催生出一帮像我这样的狗东西，天天琢磨下面五个命题：</p><p>1．如何让玩家一直沉迷</p><p>2．如何让玩家吐出更多的人民币</p><p>3．如何让玩家拉帮结伙</p><p>4．如何让玩家相互仇视</p><p>5．如何实现隐性的现金赌博和金币交易</p><p>请相信我，几乎所有做网络游戏研发的公司，都会要求策划设计了大量的功能模块来实现以上5点。衡量一个策划，尤其是数值策划是否优秀的标准，便是看以上几点在游戏实际运营中贯彻的是否彻底，当然，不同类型的游戏会有不同侧重点。</p><p>结果，在相当数量的游戏研发团队里，策划的工作焦点，不是研究如何让游戏更好玩更丰富，而是研究如何让玩家成瘾，让他们习惯党同伐异，谩骂虐杀，以及进行更安全的在线现金活动（赌博，虚拟物品交易等）。</p><p>顺理成章的，网络游戏涌现出了很多独有的东西：先是源源不断的新地图&#x2F;新怪物&#x2F;新等级&#x2F;新装备，然后是这个转生，那个飞升；接着是双倍经验，家族系统，小喇叭，PK榜，踢人权，防踢权；还有抽奖卡，金币区，10倍金币区，50倍金币区……相比那些过时的，传统的单机元素，这些新玩意儿在经济效益上获得了明显的，甚至是空前的成功。</p><p>于是我们弹冠相庆，为自己的创造力喝彩，为探索出了一条有中国特色的网络游戏事业兴旺之路手舞足蹈。</p><p>这真是网络游戏研发界最奇特的现象：我们成了终日分析某个级数通项是否合理，不停做曲线积分解微分方程的数学家；我们成了研究如何提高患者药物依赖程度，不断改进***提纯工艺的职业医师；我们成了鼓励人们无视现实规则，恣意发泄个人情绪，激化各种矛盾的职业鼓动家和武器提供商；我们成了地下赌场的庄家和各种黑市交易的中间人。</p><p>我们成了，富有经验的游戏策划。</p><blockquote><p>💬 我上一个项目的主策划是一个对数值异常执着的人。他擅长对和游戏相关的，所有包含数字的地方进行再改造，包括游戏分数，动力参数，一次活动的奖励比例等等。他总是能够敏锐发现每一个不当之处，然后重新编制全新的神奇公式改善这些不当，并为此花费大量的时间进行测试和完善。可是每当他醉心于这些所谓“平衡”和“合理”的时候，玩家却因为游戏内容的贫乏和玩法的单调悄悄流失掉了。<br>—— yocar</p></blockquote><h2 id="插曲：从反沉迷说起"><a href="#插曲：从反沉迷说起" class="headerlink" title="插曲：从反沉迷说起"></a>插曲：从反沉迷说起</h2><p>中国要出《网络游戏防沉迷系统》，这不是什么新鲜事儿。但为什么日本没有，韩国没有，欧洲没有，连网络普及率最高的美国，也只使用了游戏分级制度，而不是强制限时这么死板的做法来控制受众面？</p><p>为什么只有中国，会出台这种看似严重伤害新兴市场的法规？</p><p>定有人要跳出来了：“中国的政策制定一向这么粗暴。”</p><p>我只能说你too naive，too simple，too young！</p><p>是因为国情决定了一切。只有中国，具备了如此大量的“失意人群”，在依靠市场本身已经无法做出正确调控时，国家有必要使用行政手段拨乱反正。</p><p>何谓失意人群？我的定义是，在现实中无法获得足够的成就感，在现行教育体制下彷徨无措，在激烈的社会竞争中感到不安和失落的人群。失意人群的特性，决定了他们是网络天生的最佳用户。在这个本身就人口极度过剩，社会正处于转型期的国度，这一人群的数量之巨，直接导致了中国在短短几年内间便成为了第一网民大国和第一网游大国。回忆一下网吧如何一夜之间大街小巷梨花开，网瘾如何成为人人皆知的社会公害，便不难理解这一点。</p><p>何谓市场本身无法正确调控？一位英国的经济学家说过一段我们都耳熟能详的话：</p><p>“资本害怕没有利润或利润太少，就像自然界害怕真空一样。一旦有适当的利润，资本就胆大起来。如果有10％的利润，它就保证到处被使用；有20％的利润，它就活跃起来；有50％的利润，它就铤而走险；有100％的利润，它就敢践踏一切人间法律；有300％的利润，它就敢犯任何罪行，甚至冒绞首的危险。如果动乱和纷争能带来利润，它就敢鼓励动乱和战争。”</p><p>网游游戏运营商的背后是什么？是资本。</p><p>网络游戏的本质的是什么？是虚拟的存在感和成就感。</p><p>中国庞大的失意人群在资本眼里是什么？是最好最鲜美的待宰羊群；是世界任何地方都寻不到的超级金矿；是完美的，未开垦的，最肥沃的处女地。</p><p>现在我们可以把经典语录稍微改一改了：</p><p>“网络游戏运营商害怕没有利润或利润太少，就像他们的服务器害怕机房断电一样。一旦有适当的利润，网络游戏运营商就忘记了游戏的原罪。如果有10％的利润，它就保证到处去宣传；有20％的利润，它就开始谎称自己的良善和玩网络游戏的诸多益处；有50％的利润，它就铤而走险，玩弄人性的弱点，只为让用户沉迷自己的产品；有100％的利润，它就敢制作任何违法的内容，践踏一切现实的规则，哪怕民怨滔天；有300％的利润，它就敢于策动玩家做出最变态最疯狂的事情，甚至冒取缔的危险。如果一代人的垮掉，能带来利润，它就敢鼓励他们垮掉。”</p><p>试问，这样的国情之下，如何指望这只“看不见的手”实行有效的调控呢？如果国家还不出手阻止，它会丧心病狂到怎样的地步呢？请记住，在资本眼里，是永远不会看到那些哭喊的父母和猝死的玩家的。尸体是它的佳肴，眼泪是它的佐料，它以此为生，乐此不疲。</p><p>所以，不要听说几家大网游公司在北京鼓捣了个《北京宣言》说坚决支持反沉迷，不会影响网游盈收云云就真的相信了，那是典型中国特色“政府搭台，企业唱戏”的闹剧。一旦《网络游戏防沉迷系统》明天就实施，我保证几个老总如丧考妣午夜泪奔：）</p><h2 id="原力的黑暗面"><a href="#原力的黑暗面" class="headerlink" title="原力的黑暗面"></a>原力的黑暗面</h2><p>《星球大战》里，原力是生命所能掌握的宇宙间最强大的能量，它分为两面，光明面和黑暗面，就像光与影。光明面诞生了绝地武士，黑暗面则造就了黑武士。绝地武士用自己的力量守卫公义和所有生命的平等权益，而黑武士只为满足自己的欲望不择手段。</p><p>如果我们把原力比喻为今天的网络游戏。把原力的光明面，看作是玩家从游戏中获得的健康乐趣；而把原力的黑暗面，理解为游戏运营商背后资本的无边贪婪。那么我们游戏策划，就像年轻的阿纳金?天行者，他的原力是如此强大——他若信念坚定，世间的原力便能保持平衡和稳定；他若堕落，则整个银河将陷入万劫不复。</p><p>为了了解你们项目组的策划是否已经走入原力的黑暗面，请马上去问他这样一个问题：“你做过的所有工作中，真正能改善游戏性的部分，和只考虑赚钱而与游戏乐趣无关的部分，各占了多少？”</p><p>一个狡猾的策划会反过来教育你说，任何和游戏性看上去无关的工作，其实都会一定程度增加玩家的乐趣。</p><p>很遗憾，他已经被黑暗原力侵蚀太深了。永远不要轻信这样的谎言，就如同网络游戏运营商永远不会承认“你越宅越废材，我越高兴越HIGH”一样。</p><p>回到前面的话题，通过对整个产业一次浅显的批判，应该可以初步解释为什么策划会离玩家越来越远。最根本的原因，乃是资本异化了网络游戏的制作初衷，网络游戏被首先定位成一项能够持续赚钱的服务性业务。全部的工作，被要求围绕 “持续盈利”和“让用户在里面呆上成百上千个小时”而展开。而原来的初衷仅仅是“创造有趣的东西”。</p><p>这不是为策划开脱，导致网络游戏成为众矢之的更深层面原因，的确是来自资本的黑暗力量。我只是想提醒诸位另一种危险：在这样强大的黑暗原力的感召下，势单力薄的策划们，开始呈现整体堕落的趋势。我们正在逐渐形成一种新的游戏策划指导思想，它的核心不是关于如何制作出“有趣的，让玩家获得快乐的”游戏，而演变为如何设计出一个成功的互联网圈套。更严重的是，在国内有相当数量的优秀策划已经站在了这一黑暗面，为此推波助澜，他们不断地，卖力地补充着大量来自实践的经验，并运用心理学和统计学的知识为将其升华为各种定律和理论。</p><p>哪些特征可以表现出这种堕落的趋势？请对照你的项目组看看是否符合下面的八条：</p><ul><li>游戏原始模型的创新被压缩到几乎为零；</li><li>策划很少做前瞻性的思考，他们更多在做的是类比、修饰和抄袭；</li><li>网络游戏作为单机游戏的成分，如人物情感，世界观，任务剧情，音乐音效的完成度要求显著降低；</li><li>玩家被当成数学模型，在所有决策中，个体玩家的感受可以被完全忽略；</li><li>策划普遍具备了凌驾玩家之上的心态，他们对热爱自己游戏的“上帝”毫无虔诚可言；</li><li>如果不是工作要求，策划大都不愿意和玩家做主动的，直接的，频繁的交流，更不愿意他们干扰到自己的私人时间；</li><li>资深（数值）策划的衡量标准是设计出能够强力成瘾的系统，他们以此为荣；</li><li>头头们经常说的话是“我只关心它能不能为我赚到钱”。</li></ul><p>请务必重视这个预测。不仅因为资本的贪婪本性，也因为我国恰好正处在这样一个缺乏单机游戏文化沉淀，网络游戏市场独大的畸形生态中。在这样的大环境下，任何急功近利的火花都比其他时候更容易燎原！</p><p>也许真的会有一天——</p><p>那时的网络游戏，不再是游戏，它们是华丽画面和千锤百炼的数值体系组成的阴谋。</p><p>那时的网络游戏玩家，不再是传统意义上的游戏玩家，他们和药物依赖者别无二致。</p><p>欢迎来到NHK！</p><blockquote><p>💬 2006年上半年，我接手了一项旨在使得游戏内玩家追求多样化的工作，为此我考察了多个单机游戏，分析它们是如何提高重玩率的。在考察中，我对如特殊荣誉，额外奖励之类的设定做了大量的记录。最后，我为我们的游戏写出了一份繁复冗长的特别勋章表。这项工作带来的一个后果是，我看待单机游戏的眼光不知不觉发生了改变，以后每接触一个新游戏，我总是能先敏锐地找到它们做了哪些事情，是让玩家在通关后还可以继续玩更长的时间。可我一定是忘记了，那些东西只是点缀和彩蛋，并不是它们流行的原因。<br>—— yocar</p></blockquote><p>从资本发源，再到策划合谋，一个网络游戏这时才可以说味道彻底变坏了。它不再是为带给玩家快乐而制造的冰淇淋，它是一颗量身定做精确制导的糖衣炮弹，它的使命纯粹而残忍——榨干他们所有的钱，哪怕摧毁他们的意志和身体。</p><p>本文尽管着重于探讨策划为游戏失败所付的责任，但在这里我不得不悲观地指出：虽然大部分“纯利润”导向的网络游戏被迅速揭穿并鞭尸；虽然有思考能力的成熟玩家和有责任感的媒体都敏锐地察觉到一危险；虽然现在的市场上不把玩家当人看的游戏，生存的可能性已经微乎其微。</p><p>但是。</p><p>那些自以为高明的，老练的，邪恶的游戏策划们并没有因此醒悟，他们仍然在悄悄酝酿着更多的阴谋。他们是一群内心真正信奉“网络游戏赚钱只能靠沉迷”“做网游就是做电子鸦片”的黑武士，他们是资本鼎力推崇的业内精英，他们身经百战意志坚强，他们占了大多数。连我自己，也不过是其中一个尚未被黑暗吞噬全部良心的小辈。</p><blockquote><p>💬 2006年年初，当时《征途》刚刚崭露头角，有人在公司发起了一个内部讨论群，策划们就《征途》的收费装备，代练人偶等一系列“歪门邪道”的做法和到底史玉柱做游戏是不是赚了大钱进行了激烈的辩论。开始还有各种不同的声音，但到了最后，讨论的主题变成了“我们是不是也要像征途那般黑”。<br> —— yocar</p></blockquote><p>我亲爱的玩家，我听见了背后你们凄厉的哀嚎，可是资本总在前方对我妩媚微笑啊。</p><h2 id="运营策划的尴尬"><a href="#运营策划的尴尬" class="headerlink" title="运营策划的尴尬"></a>运营策划的尴尬</h2><p>“你们策划都是吃屎的？白痴才会去参加这种SB活动！”</p><p>听到这样的话，你或许会感到委屈，官网上的活动日历不是排的满满的么？今天攻城，明天抽奖，周末是双倍经验，下周还有“XX天使”评选决赛阶段正式开启投票。可那帮不知足的家伙在论坛上一点情面都不给，总是无休止的抱怨现在的活动千篇一律毫无新意。</p><p>《网络游戏开发》一针见血地指出，网络游戏的一半是服务。这服务，落实到策划头上，基本就相当于运营策划的工作。千万不要轻视他们对游戏成败的影响力，如果说前期的游戏策划决定了什么人会来玩，那么后期的运营策划则决定着有多少玩家会留下。</p><p>浏览各大网游公司的招聘广告，不难发现，运营策划的要求明显较其他策划为低。运营策划的要求通常是“文笔优美，能够承受压力，吃苦耐劳，有一款以上的网游经验”，游戏策划的要求则是“熟悉历史；精通奇幻文学，AD&amp;D体系；深刻了解市场同类产品；擅长写作和表达”。</p><p>简直一个是体力劳动，一个脑力劳动！</p><p>造成这种差别最初的原因，也许是来自人类潜意识里的某种劣根性——我们固执地认定原始的思想者和创造者，胜过在此基础上继续发展的生产者和经营者。在单机时代，团队里没有运营策划的概念，从那时起我们慢慢养成了一个习惯，认为一个游戏的成功，伟大的游戏策划功不可没，但从不提及优秀的运营策划。</p><p>对于网络游戏这个新生事物，也能够这么简单的理解吗？</p><blockquote><p>💬 我刚进入游戏公司时，为一个正在运营的MMORPG做运营策划，我获得的第一个任务，是“三个月内写一个活动”。后来，这个要求逐渐变为“小活动不见断，大活动每月一个”，于是我不得不制作了一些模版，来应付如此多的需求。我从没问过，为什么要写这么多活动。也从没人问过我，你对游戏的下个版本有什么意见。<br>—— yocar</p></blockquote><p>至少我所了解现状是，运营策划的任务，在大部分时候可以被简单的表述为“不要让玩家闲着”。在多数情况下，策划主管不会要求手下的运营策划对每个活动提案涉及的敏感人群，投入产出，可能风险，长远影响等因素进行预测和分析；也不会对已经结束的活动做效果总结，得失记录和横向比较。长此以往，因为缺乏有效的参照物和系统的标准，任何一个活动究竟上不上，只取决于决策者感性上的可行或不可行。</p><p>运营策划，本该是最了解玩家需求的一群策划，现实却是他们和那些真正能够改善游戏性的，高高在上的“核心策划”如隔参商。他们也的确曾在恶劣条件下了办出了让玩家叫好的活动，但因为长期的意见被忽视加之繁多而枯燥的需求，更多的活动变得模式化严重，草率和不负责任。</p><p>对游戏内某个技能的伤害数值一丝不苟，对某次活动明显的不严谨不公平置若罔闻。这种在策划上重设计轻运营的思想，这种对运营策划的“非策划级”的要求标准，对网络游戏，尤其是一个已经运营拥有一定数量玩家群的网络游戏而言，无疑是潜伏的定时**。</p><p>不能免俗，我还是试图找出了一些不成熟的，感性的运营策划经验，仅供参考。</p><p>哪些活动事后让玩家怨声载道？</p><ul><li>要求玩家不断砸钱的活动</li><li>容易导致作弊，刷分的活动</li><li>黑箱操作决定奖品最终归属的活动</li><li>难于报名，过程繁琐的活动</li><li>过于简单粗糙的赠送类活动</li><li>单调，重复，形式长期不变的活动</li><li>不能给与全部玩家公平待遇的活动</li><li>易于引起玩家间矛盾的活动</li></ul><p>哪些活动容易受到玩家欢迎？</p><ul><li>免费，方便，轻松参加的活动</li><li>体现游戏技术含量的活动</li><li>提倡玩家团队合作的活动</li><li>提供超级特殊奖励的活动</li><li>提供全新游戏内容的活动</li><li>鼓励玩家相互交流的活动</li><li>系统自动刷新获奖结果的活动</li><li>玩家参与构建游戏世界的活动</li><li>配合现实节日主题的活动</li><li>丰富和多样化的任务</li><li>紧扣游戏新版本的活动</li><li>针对玩家热点的活动</li><li>向游戏内恶意行为宣战的活动</li><li>与游戏主要目标大相径庭的活动（如小游戏，答题等）</li><li>两性主题的活动</li></ul><p>哪些活动应该谨慎举办？</p><ul><li>开支庞大的线下比赛活动</li><li>各种不伦不类的赞助活动</li><li>需投入大量人力监督的活动</li><li>得不到足够重视的调研活动</li><li>事前准备不充分的包机活动</li><li>和社会公益结合的慈善活动</li><li>公开选拔玩家明星的选秀活动</li></ul><h2 id="何苦做策划"><a href="#何苦做策划" class="headerlink" title="何苦做策划"></a>何苦做策划</h2><p>说了这么多策划的坏话，最后想为策划鸣冤几声，决没有要翻案的意思。</p><p>先点出一个事实：即使是在我们一向认为重视创意的欧美。程序员&#x2F;程序主管的收入仍然比同级别策划&#x2F;主策划多出将近30％，美术则大概多出5％～10％。这一点和广告行业可能不同，在游戏业，产品必须经过程序才能真正产生。</p><p>道理很简单：</p><p>程序需要创意，也需要专业技术。</p><p>美术需要创意，也需要专业技术。</p><p>策划需要创意，然后需要敏锐的嗅觉，丰富的经验，良好的表达技巧，但没人把这些当作专业。</p><p>如果缺程序，产品＝0。</p><p>如果缺美术，产品必定惨不忍睹。</p><p>如果缺策划，产品仍可顺利诞生。</p><p>程序对易用性的理解未必比策划差。</p><p>美术对爽快感的表现未必比策划差。</p><p>策划说，我对游戏性有深刻理解，然后程序和美术都笑了。</p><p>我承认，伟大的游戏总是来自伟大的思想，伟大的思想通常来自伟大的游戏设计师。但技术决定游戏的时代并没有完全过去，E3展每年层出不穷的FPS和新硬件技术就很能说明问题。在游戏性已经积累了厚厚的基本规则后，技术高低仍是影响游戏是否热卖的决定性因素。</p><p>何况，没人相信你能设计出“伟大的游戏”。</p><p>所以事实上，程序美术策划重要程度的差别是如此显而易见无处不在。也许只有日本的“游戏制作人”是个例外，但宫本茂们有超过20年的游戏制作经验，他们是整个游戏行业的启蒙者。亦只有这种积累，才让他们获得了超越一般分工的更高存在</p><p>说到这里，还是回到本节标题——如果你总是积极地写文档和设计数值，其他人会认为你很合格而且尊重你，但决不会认为因此你可以拿到和他们相同甚至更高的薪水。如果你能7天做一个原型，能提出解决当前疑难的更高效算法，能直接设计并拿出某个UI的效果图，其他人会尊重并佩服你。</p><p>在不长的工作经历中，我基本可以证明以上的话是真实的。</p><p>别忘了，咱们是策划，老板还巴望着咱们在创意&#x2F;经验&#x2F;文案&#x2F;眼光&#x2F;兴趣&#x2F;沟通&#x2F;外语等等方面超过其他人呢。</p><p>这么看来，尽管很多人觉得策划好混，但就前途发展而言，的确是不适合很多人的职业呢。</p><p>突然想起，CSI第一季里，老大Gil说，你的悲哀就是把它当成了工作。</p><p>路还很长，风还很邪，妖气正冲天。</p><hr><p>Nil: </p><p>就像Yocar所说整个行业都在追名逐利，选择游戏行业的人都是理想化的，都想在自己的手中孕育出心中最完美的游戏，它更多不像是一份工作，而是一份理想。</p><p>暂时的沉沦不会让我们放弃，愿游戏行业不再如Yocar所说，更多的追求创意追求本真快乐。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Yocar, 腾讯《斗战神》项目主策划&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;失败！继续下一个失败！&quot;&gt;&lt;a href=&quot;#失败！继续下一个失败！&quot; class=&quot;headerlink&quot; title=&quot;失败！继续下一个失败！&quot;&gt;&lt;/a&gt;失败！继续下一个失败！&lt;/h2&gt;&lt;p&gt;就在此时，大量的游戏研发团队正在走向失败，闭上眼睛想象一下这个画面，然后睁开眼睛看看周围。它正发生在你的身边吗？&lt;/p&gt;
&lt;p&gt;在2006年，国内有超过60款自主研发的网络游戏面世，最后活下来的并能够盈利的，不超过15款。不用怀疑这一点：超过75％的项目都直接失败了或远未达到预期！在竞争日益激烈的中国网游市场中，这个比例甚至还在提高。大盘大盘新出炉还冒着热气的游戏，等不到大规模宣传，就在各种级别的内部测试中无声无息地被倒进了泔水桶。剩下的呢？你试图回忆上个月在17173上大张旗鼓宣布公测万人空巷的国产巨作叫什么名字，却怎么也记不起来。旱花一现，用来形容今天的大部分新网游，毫不过分。&lt;/p&gt;
&lt;p&gt;到底出了什么错？&lt;/p&gt;
&lt;p&gt;是谁谋杀了我们的游戏？&lt;/p&gt;
&lt;p&gt;为什么抬眼四望，到处只见血淋淋的成品？&lt;/p&gt;
&lt;p&gt;四年前“一边睡觉一边印钞”的黄金产业消失了？&lt;/p&gt;
&lt;p&gt;可爱的玩家怎么突然都变得这么始乱终弃面目狰狞？&lt;/p&gt;
&lt;p&gt;本文并非要分析外部环境，市场竞争，文化积累，用户心理，游戏内容或者各种人品问题，而只是想从游戏开发者内部一个小小方面——也就是我所从事的游戏策划的角度，来看待游戏自主研发的失败原因。本文不是有关如何做好一个策划的指南，只是较为感性地表达作者个人的观点，并列举与此相关的实际教训，希望对那些还没有彻底失败的项目有所警示。&lt;/p&gt;</summary>
    
    
    
    <category term="Chat" scheme="http://huozk.cn/categories/Chat/"/>
    
    
    <category term="game-thinking" scheme="http://huozk.cn/tags/game-thinking/"/>
    
  </entry>
  
  <entry>
    <title>Unity项目架构设计与开发管理</title>
    <link href="http://huozk.cn/2022/01/unity-manager-intro/"/>
    <id>http://huozk.cn/2022/01/unity-manager-intro/</id>
    <published>2022-01-15T01:53:35.000Z</published>
    <updated>2023-05-25T11:22:25.174Z</updated>
    
    <content type="html"><![CDATA[<p>笔者是观摩刘钢先生讲解的<a href="https://v.qq.com/x/page/d016340mkcu.html">Unity项目架构设计与开发管理</a>后所总结记录的。</p><h2 id="EmptyGo"><a href="#EmptyGo" class="headerlink" title="EmptyGo"></a>EmptyGo</h2><p>将所有的代码放到一个空的游戏对象中；<br>使用 <code>GameObject.Find()</code> 来找到目标进行使用。<br>架构设计的雏形实现，缺点是当我们的项目越来越大的时候难以灵活管理；不适合大型项目。</p><h2 id="Simple-GameManager"><a href="#Simple-GameManager" class="headerlink" title="Simple GameManager"></a>Simple GameManager</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameManager.Instance.playSound(<span class="string">&quot;menu&quot;</span>);</span><br></pre></td></tr></table></figure><p>优点是： 是把EmptyGO做成一个单例来使用；比较适合小型项目；空物体进行全局引用。 缺点是： 把所有的逻辑都放在一个脚本中，不利于编译；而且会造成单一文件过于庞大；NO 即插即用。</p><h2 id="Manager-Of-Managers"><a href="#Manager-Of-Managers" class="headerlink" title="Manager Of Managers"></a>Manager Of Managers</h2><p>类似于分级结构，各司其职；比如音频管理，场景管理，关卡管理等，每一个都是一个单例脚本，配合使用。结构相对清晰。</p><ul><li>MainManager</li><li>EventManager：消息传递管理</li><li>AudioManager：音效管理</li><li>GUIManager：图形视图管理</li><li>PoolManager：GO管理</li><li>LevelManager： 关卡管理</li><li>GameManager：核心机制管理</li><li>SaveManager：游戏进度管理</li><li>MenuManager：菜单行为动画管理</li><li>…</li></ul><h2 id="MVCS（StrangeIOC）"><a href="#MVCS（StrangeIOC）" class="headerlink" title="MVCS（StrangeIOC）"></a>MVCS（StrangeIOC）</h2><p><img src="/images/202201/strangeioc-framework.webp" alt="Unity3D-StrongeIOC框架结构图">  </p><p>Strange是一个超轻量级且高度可扩展的控制反转控制（IoC）框架，专为C＃和Unity编写。 它包含以下功能，其中大部分是可选的：</p><ul><li>一个核心绑定框架，几乎可以让你将一个或多个任何东西绑定到一个或多个其他任何东西。</li><li>依赖注入</li><li>反射绑定显著降低了采用反射效率的开销</li><li>共享事件系统，EventDispatcher 和 Signals。</li><li>MonoBehaviour 调配</li><li>可选的MVCS（模型&#x2F;视图&#x2F;控制器&#x2F;服务）结构</li><li>…</li></ul><p>这个框架的想法很有意思；可以研究一下它的原理即源码。 地址：<a href="https://github.com/strangeioc/strangeioc">https://github.com/strangeioc/strangeioc</a></p><h2 id="MVVM（uFrame）"><a href="#MVVM（uFrame）" class="headerlink" title="MVVM（uFrame）"></a>MVVM（uFrame）</h2><p><img src="/images/202201/uframe.webp" alt="Unity3D-uFrame框架结构">  </p><p>uFrame 是为 Unity Engine 设计的 MVVM &#x2F; MV * 框架。它配备了大量功能，包括图形界面 &#x2F; 图表引擎，可生成代码甚至处理一些重新分解。图形界面显著提高所有团队成员开发和实施一致编码模型的效率。随着微软全息镜头的崛起和Unity的跨平台功能，uFrame 是构建下一个大型应用程序或游戏的终极解决方案。 包含以下功能：</p><ul><li>高质量的图形引擎</li><li>可编辑的代码生成模板</li><li>UGUI绑定</li><li>IOC &#x2F;依赖注入</li><li>完整的MV *实现 – 事件聚合</li><li>场景管理（将场景加载为具有附加加载的预制件）</li><li>在极大型项目上测试运行</li><li>开源框架</li><li>…</li></ul><h2 id="实体组件系统（ECS）"><a href="#实体组件系统（ECS）" class="headerlink" title="实体组件系统（ECS）"></a>实体组件系统（ECS）</h2><p>在2018年，Unity又重点推荐ECS；ECS是一种编写代码的方式，专注于您正在解决的实际问题：组成游戏的数据和行为。其中心为Entity，Component，System。除了出于设计原因更好地接近游戏编程之外，使用ECS可以使您更好的利用Unity的C＃job系统和Burst Compiler，充分利用当今的多核处理器。<br>这里非常推荐比较成熟的一个三方方案 <a href="https://github.com/strangeioc/strangeioc">Entitas</a>,很好的解决了代码生成的问题。<br><img src="/images/202201/entitas-framework.webp" alt="entitas 结构图"></p><ul><li>Entity 是实例,作为承载组件的载体,也是框架中维护对象的实体.</li><li>Component 只包含数据,具备这个组件便具有这个功能.</li><li>System 作为逻辑维护,维护对应的组件执行相关操作.</li></ul><p>而且使用ECS，可以让你从面向对象转向数据导向设计，这意味着重用代码更容易，并且更容易让其他人掌握并做出贡献。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔者是观摩刘钢先生讲解的&lt;a href=&quot;https://v.qq.com/x/page/d016340mkcu.html&quot;&gt;Unity项目架构设计与开发管理&lt;/a&gt;后所总结记录的。&lt;/p&gt;
&lt;h2 id=&quot;EmptyGo&quot;&gt;&lt;a href=&quot;#EmptyGo&quot; class=&quot;headerlink&quot; title=&quot;EmptyGo&quot;&gt;&lt;/a&gt;EmptyGo&lt;/h2&gt;&lt;p&gt;将所有的代码放到一个空的游戏对象中；&lt;br&gt;使用 &lt;code&gt;GameObject.Find()&lt;/code&gt; 来找到目标进行使用。&lt;br&gt;架构设计的雏形实现，缺点是当我们的项目越来越大的时候难以灵活管理；不适合大型项目。&lt;/p&gt;
&lt;h2 id=&quot;Simple-GameManager&quot;&gt;&lt;a href=&quot;#Simple-GameManager&quot; class=&quot;headerlink&quot; title=&quot;Simple GameManager&quot;&gt;&lt;/a&gt;Simple GameManager&lt;/h2&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GameManager.Instance.playSound(&lt;span class=&quot;string&quot;&gt;&amp;quot;menu&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;优点是： 是把EmptyGO做成一个单例来使用；比较适合小型项目；空物体进行全局引用。 缺点是： 把所有的逻辑都放在一个脚本中，不利于编译；而且会造成单一文件过于庞大；NO 即插即用。&lt;/p&gt;
&lt;h2 id=&quot;Manager-Of-Managers&quot;&gt;&lt;a href=&quot;#Manager-Of-Managers&quot; class=&quot;headerlink&quot; title=&quot;Manager Of Managers&quot;&gt;&lt;/a&gt;Manager Of Managers&lt;/h2&gt;&lt;p&gt;类似于分级结构，各司其职；比如音频管理，场景管理，关卡管理等，每一个都是一个单例脚本，配合使用。结构相对清晰。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MainManager&lt;/li&gt;
&lt;li&gt;EventManager：消息传递管理&lt;/li&gt;
&lt;li&gt;AudioManager：音效管理&lt;/li&gt;
&lt;li&gt;GUIManager：图形视图管理&lt;/li&gt;
&lt;li&gt;PoolManager：GO管理&lt;/li&gt;
&lt;li&gt;LevelManager： 关卡管理&lt;/li&gt;
&lt;li&gt;GameManager：核心机制管理&lt;/li&gt;
&lt;li&gt;SaveManager：游戏进度管理&lt;/li&gt;
&lt;li&gt;MenuManager：菜单行为动画管理&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;MVCS（StrangeIOC）&quot;&gt;&lt;a href=&quot;#MVCS（StrangeIOC）&quot; class=&quot;headerlink&quot; title=&quot;MVCS（StrangeIOC）&quot;&gt;&lt;/a&gt;MVCS（StrangeIOC）&lt;/h2&gt;</summary>
    
    
    
    <category term="Unity" scheme="http://huozk.cn/categories/Unity/"/>
    
    
    <category term="unity-framework" scheme="http://huozk.cn/tags/unity-framework/"/>
    
  </entry>
  
  <entry>
    <title>保持Unity项目结构清晰的7种方法</title>
    <link href="http://huozk.cn/2021/12/project-list-clear/"/>
    <id>http://huozk.cn/2021/12/project-list-clear/</id>
    <published>2021-12-29T01:23:05.000Z</published>
    <updated>2023-05-19T02:38:22.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天我在Quora上看到的一个人，询问程序员如何编写包含10,000多行代码以上的项目。当软件变大时，维护起来就更困难了，这是事实。所以这就是事情 – 如果你不保持你的项目井然有序，你将很难跟上节奏。稍后，您会发现自己把更多的时间浪费在处理混乱的项目，而不是添加新功能。任何Unity项目都是这样。以下是（在我看来）比较重要的建议，可以帮助保持项目的有序性。</p><h2 id="资源目录结构"><a href="#资源目录结构" class="headerlink" title="资源目录结构"></a>资源目录结构</h2><p>如果不提及组织项目目录结构，我们就不能谈论组织。Unity在这方面给你一个完全的自由，但正因为如此，它经常变得非常混乱。这是我个人使用的目录结构：</p><ul><li>3rd-Party</li><li>Animations</li><li>Audio</li><li>Music</li><li>SFX</li><li>Materials</li><li>Models</li><li>Plugins</li><li>Prefabs</li><li>Resources</li><li>Textures</li><li>Sandbox</li><li>Scenes</li><li>Levels</li><li>Other</li><li>Scripts</li><li>Editor</li><li>Shaders</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>不要将任何资源存放在根目录中。尽可能使用子目录。</li><li>除非确实需要，否则不要在根目录中创建任何其他目录。</li><li>与命名保持一致。如果您决定将camel case用于目录名称和低字母用于资产，请坚持使用该约定。</li><li>不要尝试将特定于上下文的资源移动到常规目录。例如，如果从模型生成材质，请不要将它们移动到Materials目录，因为稍后您将不知道它们来自何处。</li><li>使用第三方存储从资源商店导入的资源。它们通常有自己的结构，不应该改变。</li><li>使用Sandbox 目录进行您不完全确定的任何实验。在处理这类事情时，你最不想要关心的是一个合适的组织。执行您想要的操作，然后在确定要将其包含在项目中时将其删除或整理。当您与其他人一起处理项目时，请创建您的个人Sandbox子目录，如： Sandbox &#x2F; JohnyC。</li></ul><h2 id="场景层次结构"><a href="#场景层次结构" class="headerlink" title="场景层次结构"></a>场景层次结构</h2><p>在项目的层次结构旁边还有场景层次结构。和以前一样，我会给你一个模板。您可以根据自己的需要进行调整。</p><ul><li>Management</li><li>GUI</li><li>Cameras</li><li>Lights</li><li>World</li><li>Terrain</li><li>Props</li><li>_Dynamic</li></ul><h3 id="几条原则："><a href="#几条原则：" class="headerlink" title="几条原则："></a>几条原则：</h3><ul><li>所有的空物体应保持在 <code>Vector3.zero</code>，默认旋转角度和缩放比例。</li><li>当您在运行时实例化(克隆) 对象时，请确保将其放在 _Dynamic 中 – 不要污染层次结构的根目录，否则您将发现难以浏览它。</li><li>对于仅作为脚本容器的空对象，请使用“@”作为前缀 – 例如@Cheats。</li></ul><h2 id="为所有物体设置预制体（Prefab）"><a href="#为所有物体设置预制体（Prefab）" class="headerlink" title="为所有物体设置预制体（Prefab）"></a>为所有物体设置预制体（Prefab）</h2><p>Unity中的预制体并不完美，但它们是您分享预先配置的对象层次结构的最佳选择。一般来说，尝试设置你放在场景上的所有东西为预制体。只需向其中添加一个或多个预制体，您就可以从空场景中创建新关卡。<br>您应该使用预制体的原因是，当预制体更改时，所有实例也会更改。有100个级别，并希望在所有这些级别上添加相机效果？不是问题！如果您的相机是预制体，只需将相机效果添加到相机预制体即可！<br>请注意，您不能在另一个预制件中安装预制体。改为使用链接 – 有一个需要分配预制体的字段，并确保在创建实例时分配它。当有意义时，请考虑在 <code>Awake()</code> 或 <code>OnEnable()</code> 中自动连接预制实例。</p><h2 id="了解如何使用版本控制系统（VCS）"><a href="#了解如何使用版本控制系统（VCS）" class="headerlink" title="了解如何使用版本控制系统（VCS）"></a>了解如何使用版本控制系统（VCS）</h2><p>您可能已经了解了有关GIT，Subversion或任何其他VCS的信息。事实上，“了解某事”只是你可能学到的一小部分。您应该专注于了解您选择的重要但不经常使用的VCS功能。为什么？主要是因为VCS系统比您想象的要强大得多，不幸的是，许多用户使用它们只不过是备份和同步解决方案。例如，您是否知道GIT允许您存储更改，因此您可以在以后处理它们而无需向主分支提交任何内容？</p><p>程序员倾向于在以后需要时注释掉代码块。不要那样做！如果您正在使用VCS，请了解如何快速浏览文件的先前版本。熟悉它时，如果没有不必要的注释代码块，代码看起来会更好。</p><p>这里有一个很好的GIT用户提示资源：<a href="http://gitready.com/">http://gitready.com</a></p><h2 id="学习编写编辑器脚本"><a href="#学习编写编辑器脚本" class="headerlink" title="学习编写编辑器脚本"></a>学习编写编辑器脚本</h2><p>Unity在可扩展性方面是一个很棒的游戏引擎（参见Assets Store）。学习如何编写编辑器脚本并利用这些知识。您没有必要为脚本创建精美的GUI，它可以是简单的事情，因为菜单条目正在做一些有用的事情。以下是我不久前创建的编辑器脚本的一些示例：</p><p>例如：</p><ul><li>Google表格.csv下载 – 我在Google云端硬盘上保存了一个翻译电子表格。它自动将最新版本下载为.csv文件，因此我从未必须手动完成。</li><li>随机化树的位置，旋转和大小 – 我有很多树，并希望它看起来更像森林而不是网格。</li><li>创建分发 – 为指定目标构建，压缩所有文件并复制到正确的位置。</li><li>源代码中的字符串替换 – 我有几个包含应用程序版本的文件。</li></ul><p>您可以从官方文档中学习如何创建编辑器脚本。</p><h2 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h2><p>你听说过防御性编程吗？维基百科将其定义如下：</p><p>防御性编程是一种防御性设计，旨在确保在不可预见的情况下软件的持续功能。特别是当一个软件被滥用时，使用防御性编程技术。<br>通常，当您编写MonoBehaviours时，您应该确保：</p><p>设置所有需要的引用<br>存在所有必需的组件<br>如果您使用单身，请确保它们存在<br>如果您正在搜索对象并期望找到某些内容，请尽快进行<br>混合编辑器代码（<code>ExecuteInEditMode</code> 和 <code>#if UNITY_EDITOR</code>）在运行场景之前进行尽可能多的检查<br>对于其中许多检查，您可以使用断言。</p><h2 id="添加作弊器"><a href="#添加作弊器" class="headerlink" title="添加作弊器"></a>添加作弊器</h2><p>在学习如何编写编辑器脚本之后，您应该能够编写一组编辑器内作弊。它可以作为解锁某些内容的菜单条目（例如所有级别）。它很容易创建：</p><p>一般来说，你应该写作弊，让你：</p><ul><li>解锁所有关卡，角色，物品等</li><li>让你无敌</li><li>修改时间，金钱，硬币等值</li><li>可以看到玩家不应该看到的东西</li><li>还有其他任何可以帮助您测试游戏的东西</li><li>当然更实际（但更难写）是游戏中的作弊。这些类型的作弊可以在Unity编辑器外部执行，但这部分显示更加必要。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前几天我在Quora上看到的一个人，询问程序员如何编写包含10,000多行代码以上的项目。当软件变大时，维护起来就更困难了，这是事实。所以这就是事情 – 如果你不保持你的项目井然有序，你将很难跟上节奏。稍后，您会发现自己把更多的时间浪费在处理混乱的项目，而不是添加新功能。任何Unity项目都是这样。以下是（在我看来）比较重要的建议，可以帮助保持项目的有序性。&lt;/p&gt;
&lt;h2 id=&quot;资源目录结构&quot;&gt;&lt;a href=&quot;#资源目录结构&quot; class=&quot;headerlink&quot; title=&quot;资源目录结构&quot;&gt;&lt;/a&gt;资源目录结构&lt;/h2&gt;&lt;p&gt;如果不提及组织项目目录结构，我们就不能谈论组织。Unity在这方面给你一个完全的自由，但正因为如此，它经常变得非常混乱。这是我个人使用的目录结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3rd-Party&lt;/li&gt;
&lt;li&gt;Animations&lt;/li&gt;
&lt;li&gt;Audio&lt;/li&gt;
&lt;li&gt;Music&lt;/li&gt;
&lt;li&gt;SFX&lt;/li&gt;
&lt;li&gt;Materials&lt;/li&gt;
&lt;li&gt;Models&lt;/li&gt;
&lt;li&gt;Plugins&lt;/li&gt;
&lt;li&gt;Prefabs&lt;/li&gt;
&lt;li&gt;Resources&lt;/li&gt;
&lt;li&gt;Textures&lt;/li&gt;
&lt;li&gt;Sandbox&lt;/li&gt;
&lt;li&gt;Scenes&lt;/li&gt;
&lt;li&gt;Levels&lt;/li&gt;
&lt;li&gt;Other&lt;/li&gt;
&lt;li&gt;Scripts&lt;/li&gt;
&lt;li&gt;Editor&lt;/li&gt;
&lt;li&gt;Shaders&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;注意：&quot;&gt;&lt;a href=&quot;#注意：&quot; class=&quot;headerlink&quot; title=&quot;注意：&quot;&gt;&lt;/a&gt;注意：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不要将任何资源存放在根目录中。尽可能使用子目录。&lt;/li&gt;
&lt;li&gt;除非确实需要，否则不要在根目录中创建任何其他目录。&lt;/li&gt;
&lt;li&gt;与命名保持一致。如果您决定将camel case用于目录名称和低字母用于资产，请坚持使用该约定。&lt;/li&gt;
&lt;li&gt;不要尝试将特定于上下文的资源移动到常规目录。例如，如果从模型生成材质，请不要将它们移动到Materials目录，因为稍后您将不知道它们来自何处。&lt;/li&gt;
&lt;li&gt;使用第三方存储从资源商店导入的资源。它们通常有自己的结构，不应该改变。&lt;/li&gt;
&lt;li&gt;使用Sandbox 目录进行您不完全确定的任何实验。在处理这类事情时，你最不想要关心的是一个合适的组织。执行您想要的操作，然后在确定要将其包含在项目中时将其删除或整理。当您与其他人一起处理项目时，请创建您的个人Sandbox子目录，如： Sandbox &amp;#x2F; JohnyC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;场景层次结构&quot;&gt;&lt;a href=&quot;#场景层次结构&quot; class=&quot;headerlink&quot; title=&quot;场景层次结构&quot;&gt;&lt;/a&gt;场景层次结构&lt;/h2&gt;&lt;p&gt;在项目的层次结构旁边还有场景层次结构。和以前一样，我会给你一个模板。您可以根据自己的需要进行调整。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Management&lt;/li&gt;
&lt;li&gt;GUI&lt;/li&gt;
&lt;li&gt;Cameras&lt;/li&gt;
&lt;li&gt;Lights&lt;/li&gt;
&lt;li&gt;World&lt;/li&gt;
&lt;li&gt;Terrain&lt;/li&gt;
&lt;li&gt;Props&lt;/li&gt;
&lt;li&gt;_Dynamic&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Unity" scheme="http://huozk.cn/categories/Unity/"/>
    
    
    <category term="unity-project" scheme="http://huozk.cn/tags/unity-project/"/>
    
  </entry>
  
  <entry>
    <title>你好 Hexo</title>
    <link href="http://huozk.cn/2021/12/hello-world/"/>
    <id>http://huozk.cn/2021/12/hello-world/</id>
    <published>2021-12-29T00:01:05.000Z</published>
    <updated>2023-05-19T02:38:22.597Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">this is first blog about hexo.</summary>
    
    
    
    
  </entry>
  
</feed>
