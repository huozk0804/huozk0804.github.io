<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一剑光寒耀九州</title>
  
  
  <link href="http://huozk.cn/atom.xml" rel="self"/>
  
  <link href="http://huozk.cn/"/>
  <updated>2023-05-19T01:58:52.445Z</updated>
  <id>http://huozk.cn/</id>
  
  <author>
    <name>Nil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[译介]Unity基础教程：(一)创建一个时钟</title>
    <link href="http://huozk.cn/2022/03/catlike-base-building-a-clock/"/>
    <id>http://huozk.cn/2022/03/catlike-base-building-a-clock/</id>
    <published>2022-03-02T01:46:42.000Z</published>
    <updated>2023-05-19T01:58:52.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用简单的对象构建一个时钟。</p><p>写一个C#脚本。</p><p>转动时钟的指针以显示时间。</p><p>对钟臂进行动画处理。</p></blockquote><p>这是关于学习使用Unity基础知识的系列教程中的第一个教程。在本教程中，我们将创建一个简单的时钟，并对脚本组件进行编程，让它显示当前时间。你不需要有任何使用Unity编辑器的经验，但需要你有一些使用多窗口编辑器应用程序的经验。</p><p>在我所有教程的底部，你可以找到教程许可证的链接，包含完成的教程项目的资源库，以及教程页面的PDF版本。</p><p>本教程是用Unity 2020.3.6f1制作的。</p><p><img src="https://static.huozk.cn/20220814-4585c7a8fa39ec03fbfc78ffaccc5b41555bc348a1e5f61f605b11e12c84ccca.jpg" alt="这是时钟的最终效果"></p><h1 id="Creating-a-Project"><a href="#Creating-a-Project" class="headerlink" title="Creating a Project"></a>Creating a Project</h1><p>在开始使用Unity编辑器之前，我们必须首先创建一个项目。</p><h2 id="1-1-新项目"><a href="#1-1-新项目" class="headerlink" title="1.1 新项目"></a>1.1 新项目</h2><p>当你打开Unity时，你会看到Unity Hub。这是一个启动器和安装程序，在这里你可以创建或打开项目，以及安装管理Unity版本，并做一些其他事情。如果你没有安装Unity2020.3或更高版本，现在就请添加它吧。</p><details>    <summary>哪些Unity版本是合适的？</summary>    <p>Unity每年会发布很多个新版本。其中有两个平行版本发布时间表。最稳定和安全的是LTS版本。LTS代表长期支持，在Unity说明下是支持两年。</p>    <p>我的教程坚持使用LTS版本，其中2020.3是最新版本。本教程特别使用2020.3.6。版本号的第三部分表示补丁版本。补丁版本包含错误修复，很少有新功能。另一个f1后缀表示官方最终版本。任何2020.3版本都可以用于本教程。</p></details><p>最高的Unity版本，如2021.1 通常属于开发分支，它很可能引入了新的功能，也可能删除了旧的功能。这些版本并不像LTS版本那样可靠，每个版本仅有几个月的支持时间。</p><p>偶尔教程中包含一些提问回答环节，<del>它们被包装在灰色的格子里，就像上面那样。在页面中，答案默认是隐藏的。可以通过点击问题来打开关闭。</del>（注：译文中使用引用格式处理！）</p><p>当我们创建一个新项目时，可以选择它的Unity版本和初始化模板。我们将使用标准的3D模板。一旦它被创建，它就会被添加到项目列表中，并在Unity编辑器的选定版本中被打开。</p><details>    <summary>我可以用不同的渲染管线来创建一个项目吗？</summary>    <p>可以，唯一的区别是，项目的默认场景中会有更多的东西，你的材质看起来也会不同。你的项目也会包含相应的包。</p></details><h2 id="1-2-编辑界面布局"><a href="#1-2-编辑界面布局" class="headerlink" title="1.2 编辑界面布局"></a>1.2 编辑界面布局</h2><p>如果你还没有设置编辑器布局，最终将使用默认的窗口布局。</p><p><img src="https://static.huozk.cn/20220814-32bf9f548c61a327ae415929fa14c15bc12eea0f61fe28f4ca68d8a0db25d3c7.jpg" alt="默认的编辑器布局。">  </p><p>默认布局包含了我们需要的所有窗口，但可以按照你自的意思，通过重新排布和分组窗口来设置。也可以打开和关闭某些窗口，比如资源商店(Asset Store)的窗口。每个窗口都有自己的配置选项，可以通过窗口右上角的三点按钮进入。除此之外，大多数窗口都有一个带有更多选项的工具条。如果你的窗口看起来与教程中的不一样；例如，场景窗口(Scene)有一个统一的背景而不是一个天空盒，那么它的某个选项是不一致的。</p><p>还可以通过Unity编辑器右上方的下拉菜单切换到一个预先配置好的布局。也可以在那里保存你当前的布局，这样可以在以后需要的时候恢复。</p><h2 id="1-3-包"><a href="#1-3-包" class="headerlink" title="1.3 包"></a>1.3 包</h2><p>Unity的功能是基于模块化的。除了核心功能，还有一些额外的包可以下载并且引入到你的项目中。默认的3D项目中也包含了一些默认的包，你可以在项目窗口(Project)的<em>Packages</em>下看到这些包。</p><p><img src="https://static.huozk.cn/20220814-947cc4a052fa4e80a127116c11a25c1a41b0061a7e9727a6c5dc511af86f8e5c.png" alt="3D模板默认引入包">  </p><p>这些包可以被隐藏，方法是点击项目窗口(Project)右上方类似眼睛的按钮，上面有一个破折号。这纯粹是为了减少编辑器中的视觉混乱，这些包仍然是项目的一部分。这个按钮还显示有多少个这样的包。</p><p>你可以通过包管理器来管理哪些包可以被包含在你的项目中，包管理器可以通过 <em>Window&#x2F;Package Manager</em> 选项打开。</p><p><img src="https://static.huozk.cn/20220814-fc45df6641f8f925649df9bdab8c6be338bbaba172494fe4ab93eb3bc2c04166.png" alt="包管理器，只显示项目中已经引用的包。"> </p><p>这些包为Unity增加了额外的功能。例如，Visual Studio Editor增加了对Visual Studio编辑器的支持，用于编写代码。本教程不会使用项目中已引用包的功能，所以我把它们都删除了。唯一的例外是Visual Studio Editor，因为那是我用来写代码的编辑器。如果你使用其他的编辑器，如果它的集成包存在的话，你可以导入它。</p><details>    <summary>你不也需要Visual Studio代码编辑器包吗？</summary>    <p>尽管名字相似，但Visual Studio和Visual Studio Code是两个不同的编辑器。你只需要其中一个包，这取决于你使用哪一个编辑器。</p></details><p>移除软件包的最简单方法是，首先使用工具栏将软件包列表限制为只在项目中(In Project)。然后依次选择一个包并使用窗口右下方的移除按钮(Remove)。Unity在每次删除后都会重新编译，所以需要几秒钟才能完成这个过程。</p><p>移除除了Visual Studio Editor以外的所有引入包后，可以看到在项目窗口(Project)中只剩下三个包：Custom NUnit, Test Framework, 和Visual Studio Editor。其他两个仍然存在，因为Visual Studio Editor依赖于它们。</p><p>你还可以通过项目设置窗口(Project Settings)使依赖和隐藏导入的包在包管理器中可见，通过<em>Edit &#x2F; Project Settings…<em>打开。选择其包管理器类别，然后在高级设置下启用</em>Show Dependencies</em>。</p><p><img src="https://static.huozk.cn/20220814-0c97bc29349d4873128f9656cd7c7c95876d2162400b6e36d68df5e446ea1914.jpg" alt="包管理项目设置，打开Show Dependencies。"> </p><p>包管理项目设置，打开Show Dependencies。</p><h2 id="1-4-颜色空间"><a href="#1-4-颜色空间" class="headerlink" title="1.4 颜色空间"></a>1.4 颜色空间</h2><p>现在的渲染通常是在线性色彩空间中进行的，但是Unity仍然默认配置为使用伽马色彩空间。为了获得最佳的视觉效果，选择项目设置窗口(Project Settings)中的播放器(Player)类别，打开其他设置(Other Settings)面板，向下滚动到其渲染部分(Rendering)。确保色彩空间(Color Space)被设置为线性(Liner)。Unity会显示警告，这可能需要很长的时间，但对于一个几乎是空的项目来说，不会出现这种情况。确认切换。</p><p><img src="https://static.huozk.cn/20220814-4114a4a838a9023df3955f44ede2be51a9f8f9ebb926e02c5f3dacb0ec00b0ab.png" alt="色彩空间设置为线性。"></p><details>    <summary>有理由使用伽马色彩空间吗？</summary>    <p>只有当你的目标平台是旧硬件或旧的图形API的时候。OpenGL ES 2.0和WebGL 1.0不支持线性空间，此外，在老旧的移动设备上，伽玛可以比线性空间更快。</p></details><h2 id="1-5-示例场景-Sample-Scene"><a href="#1-5-示例场景-Sample-Scene" class="headerlink" title="1.5 示例场景(Sample Scene)"></a>1.5 示例场景(Sample Scene)</h2><p>新项目中包含一个名为Sample Scene的示例场景，默认打开。你可以在项目窗口(Project)的<em>Assets&#x2F;Scenes</em>下找到它。</p><p><img src="https://static.huozk.cn/20220814-8db777a39687111a3ec7195e6366c8d026b436e949238365ac0c94e1bafc7fdb.png" alt="项目窗口中的样例场景。">  </p><p>默认情况下，项目窗口(Project)使用两栏式布局(Two Column Layout)。你可以通过它的三点式配置菜单选项切换到单栏布局(One Column Layout)。</p><p><img src="https://static.huozk.cn/20220814-f489bed22ccbcceb4c1b0ee18e86e90f97130aa780bd5f90e2ac13d6b8049aa6.png" alt="一栏式布局。">  </p><p>这个样本场景包含一个主摄像机(Main Camera)和一个定向灯光(Direction Light)。这些都是游戏对象。它们被列在层次结构窗口(Hierarchy)中，在场景的下面。</p><p><img src="https://static.huozk.cn/20220814-2a53fe3188f81a7d7ac2d4d69cb3ec910b308539ae50a3dcd1437f505a594d1f.png" alt="场景中的对象层次。">  </p><p>你可以通过层次结构窗口(Hierarchy)或场景窗口(Scene)选择一个游戏对象。相机有一个场景图标，看起来像一个老式的胶片相机，而定向灯的图标则看起来像一个太阳。</p><p><img src="https://static.huozk.cn/20220814-b6c136e50147c5f6e402b12a1640242f94c5e8355e4cb6cb9d128b45964bd3bf.png" alt="场景窗口中的图标。">  </p><details>    <summary>如何在场景窗口中进行导航？</summary>    <p>你可以使用alt或option键与鼠标结合来旋转视图。也可以使用方向键来移动视点，并通过鼠标滚轮进行缩放。另外，按F键可以将视角聚焦到当前选定的游戏对象上。当然，还有其他更多的可操作性，但这些足以让你在场景中找到方向。</p>    <p>当一个物体被选中时，关于它的详细信息将显示在检查器窗口(Inspector)中，但我们会在需要时再介绍这些。我们不需要修改摄像机和灯光，所以我们可以通过点击层次结构窗口(Hierarchy)中它们左边的眼睛图标来把它们在场景中隐藏起来。这个图标在默认情况下是不可见的，但是当我们把鼠标光标悬停在游戏对象前面时，就会出现。这么做纯粹是为了减少场景窗口中的视觉杂乱。</p></details><p><img src="https://static.huozk.cn/20220814-76790001af396bbcb80832b277a3da8159715bd03abe06ad015f0cd8717603da.png" alt="隐藏的物体。">  </p><details>    <summary>眼睛旁边的手状图标是做什么的？</summary>    <p>在包含眼睛图标的那一列旁边，有着类似手的图标。这些图标在默认情况下也是不可见的。只有当一个游戏对象的手部图标处于活动状态时，不可以通过场景窗口(Scene)选择该对象。这样你就可以通过在场景窗口(Scene)点击选中的反应来控制对象。</p></details><h1 id="创建一个简单的时钟"><a href="#创建一个简单的时钟" class="headerlink" title="创建一个简单的时钟"></a>创建一个简单的时钟</h1><p>现在我们的项目已经正确设置好了，可以开始创建我们的时钟了。</p><h2 id="2-1-创建一个游戏对象"><a href="#2-1-创建一个游戏对象" class="headerlink" title="2.1 创建一个游戏对象"></a>2.1 创建一个游戏对象</h2><p>首先需要一个游戏对象来表示时钟。我们将从最简单的游戏对象开始，也就是一个空的游戏对象(空物体)，可以通过<em>GameObject&#x2F;Create Empty</em>选项来创建。另外，你也可以使用层次结构窗口(Hierarchy)的上下文菜单中的<em>Create Empty</em>选项，还可以通过另一种方式点击打开，通常是右击或用两根手指敲击。这将把创建的游戏对象添加到场景中。它显示在SampleScene场景下的层次结构窗口(Hierarchy)中，并处于被选中状态，现在场景名字旁边被标记为星号，表示它有未保存的修改，记得保存。现在你可以修改名字，或者以后再做更改。</p><p><img src="https://static.huozk.cn/20220814-0a1a02dff4309ed83b76a6d74d67178e31226f072dcf7847b4d49d0518c5a890.png" alt="选择了新游戏对象的层次结构窗口。">  </p><p>选择了新游戏对象的层次结构窗口。</p><p>只要游戏对象处于被选中的状态，检查器窗口(Inspector)就会显示它的详细信息。顶部是标题，上面有对象的名称和一些其他的配置。默认情况下，该对象是被启用的，且不是静态的，没有被更改标签，位于默认层级上。这些设置都不用做修改，我们需要把它重命名为时钟(Clock)。</p><p><img src="https://static.huozk.cn/20220814-a297cb552889d22d43f21775b0b5af0c0d3dcdcdce89e36ee94b93feff7813e8.png" alt="选定时钟的检查器窗口。">  </p><p>标题下面是该游戏对象的所有组件列表。每个3D对象的顶部总会有一个<code>Transform</code>组件，这就是时钟目前拥有的所有组件。它的作用主要是控制游戏对象的位置、旋转角度和大小比例。现在确保所有时钟的位置和旋转角度都设置为0，其大小比例应该统一为1。</p><details>    <summary>2D对象怎么办？</summary>    <p>当使用的是2D而不是3D对象时，你可以忽略三个维度中的一个。对于专门用于2D的对象，如UI，通常有一个<code>RectTransform</code>来代替<code>Transform</code>，它是一个特殊的<code>Transform</code>组件。</p></details><p>因为游戏对象是空的，它在场景窗口(Scene)中是处于不可见的。不过，在游戏对象的位置，也就是在世界的中心，可以看到一个操作工具。</p><p><img src="https://static.huozk.cn/20220814-5c2cc39e31c9260e95c9afe10a0d7113ac714ef955d2b36fdda6a79ce723738b.png" alt="用移动工具选择。">  </p><details>    <summary>为什么我在选择时钟(clock)后没有看到操纵工具？</summary>    <p>操纵工具存在于场景窗口(Scene)中。请确保你看到的是场景窗口(Scene)，而不是游戏窗口(Game)。</p></details><p>当前处于哪个操纵工具，可以通过编辑器工具栏左上方的按钮来控制。这些模式也可以通过快捷键Q、W、E、R、T和Y键激活。该组中最右边的按钮是用来启用自定义编辑器工具的，我们没有这个工具。默认情况下，移动工具是激活的。</p><p><img src="https://static.huozk.cn/20220814-557da9fe4bd16dfa2d2b8c1debbc3dabbd0ee418135b696ef1144be2a38cf395.jpg" alt="操纵模式工具栏。">  </p><p>在模式按钮旁边还有三个按钮，用来控制操作工具的位置、方向和捕捉。</p><h2 id="2-2-创建时钟的表盘"><a href="#2-2-创建时钟的表盘" class="headerlink" title="2.2 创建时钟的表盘"></a>2.2 创建时钟的表盘</h2><p>虽然我们已经拥有一个时钟对象，但还没有看到任何东西。现在必须给它添加3D模型，这样才能有物体被渲染出来。Unity内置了一些原始游戏对象，可以通过使用它们来建立一个简单的时钟。让我们首先通过<em>GameObject&#x2F;3D Object&#x2F;Cylinder</em>向场景添加一个圆柱体，确保它具有与我们的时钟相同的<code>Transform</code>数值。</p><p><img src="https://static.huozk.cn/20220814-679b08215ae6851c0d5949401baf85bbf6d8e8ed58e37689960d6293d2c07dc4.png" alt="代表一个圆柱体的游戏对象。">  </p><p>新对象比一个空对象多了三个组件。首先，它有一个<code>MeshFilter</code>，它包含了对内置圆柱体网格的引用。</p><p><img src="https://static.huozk.cn/20220814-03e3e6c3f509647df6cb084ba720a3c7967b05693e7a0cb713f2f08a1bb1555d.png" alt="MeshFilter组件，设置为圆柱体。">  </p><p>其次是一个<code>MeshRenderer</code>。这个组件的作用是确保对象的网格被渲染出来。它也决定了渲染时使用什么材质，也就是默认材质。这个材质也会显示在检查器中，在组件列表的最下面。</p><p><img src="https://static.huozk.cn/20220814-571f9f5b5ba1ab3dbc226892abf0183cd27403f108de6c37370c3a9ee91acf99.png" alt="MeshRenderer组件，设置为默认材质。">  </p><p>第三个是<code>CapsuleCollider</code>，它用于3D物理模拟。这个物体代表一个圆柱体，但它有一个胶囊碰撞器，因为Unity没有一个原始的圆柱体碰撞器。而且我们不需要它，所以可以删除这个组件。如果你想让时钟具有物理效果，最好使用<code>MeshCollider</code>组件。组件可以通过其右上角的三点式下拉菜单来移除(Remove Compont)。</p><p><img src="https://static.huozk.cn/20220814-e26c420c9e2cd19202493b4848acc26c95b1d5316fb49ae198ffb7daff8b3010.png" alt="没有碰撞器的圆柱体。">  </p><p>我们将通过压扁圆柱体来把它变成时钟的表盘。这是通过减少其大小比例的Y值来实现，把它减少到0.2。由于圆柱体的网格有两个单位高，它的有效高度变成了0.4个单位。让我们制作一个比较大的时钟，所以应该将其比例的X和Z值增加到10。</p><p><img src="https://static.huozk.cn/20220814-8d148be27b36dc1fba347eadd0cafd209298f10ef68a7bbf80dca7a3fa8192c6.png" alt="缩放的圆柱体。 ">  </p><p>时钟应该是竖直立在或挂在墙面上的，但它的表盘目前是平躺着的。我们可以通过将圆柱体旋转四分之一圆的角度来解决这个问题。在Unity中，X轴指向右边，Y轴指向上方，Z轴指向前方。为了让我们在设计时钟时考虑到相同的方向，也就是说，当我们沿着Z轴看它时，我们可以看到它的正面。需要设置圆柱体的X值即旋转角度为90，并调整场景视图，使时钟的正面可见，所以移动工具的蓝色Z轴箭头指向远离你的方向，穿透屏幕。</p><p><img src="https://static.huozk.cn/20220814-8595906dbe17dfa15317e5991459bbc2c01b177b531d9eea875edb690cb8790b.png" alt="旋转的圆柱体。">  </p><p>将圆柱体对象的名称改为<em>Face</em>，因为它代表了时钟的表盘。但是它只是时钟的一个部分，所以让它成为时钟对象的一个子对象。我们通过在层次结构窗口(Hierarchy)中把表盘(Face)拖到时钟上来实现这一点。</p><p><img src="https://static.huozk.cn/20220814-f6e2da5748997972c9bd89c085bab25b05db3939f6c23679f50dc3d9348741df.png" alt="钟表子对象表盘。">  </p><p>子对象受制于其父对象的变换。这意味着当时钟(Clock)改变位置时，表盘(Face)也会跟随改变。这就好像它们是一个单一的实体。旋转和缩放也是如此。你可以用它来制作复杂的对象层次。</p><h2 id="2-3-创建时钟刻度"><a href="#2-3-创建时钟刻度" class="headerlink" title="2.3 创建时钟刻度"></a>2.3 创建时钟刻度</h2><p>钟表表面的外环通常有标记，有助于表明显示的时间。这就是所谓的时钟刻度。让我们用方块来表示一个12小时的时钟时间。</p><p>通过<em>GameObject&#x2F;3D Object&#x2F;Cube</em>向场景添加一个立方体对象，将其命名为<em>Hour Indicator 12</em>，同时使其成为Clock的子对象。子对象在层次结构中的顺序并不重要，可以把它放在表盘的上方或下方。</p><p><img src="https://static.huozk.cn/20220814-2b4aaa7060b80fb5c1084ad226427e8d88c7ddaeba9c23a1b851064940aaafcc.png" alt="钟表的子对象-刻度点。 ">  </p><p>将它的比例(Scale)X轴设置为0.5，Y轴设置为1，Z轴设置为0.1，这样它就变成了一个狭长的扁平块。然后设置它的位置(Position)X轴为0，Y轴为4，Z轴为-0.25。这样就会把它放在表盘的上面，在表示刻度12点的位置，同时删除它的<code>BoxCollider</code>组件。</p><p><img src="https://static.huozk.cn/20220814-8071c8b7ace5696a20d6c2e384497d52cad20eba54bfd86709be57ba82033985.png" alt="刻度12点位置显示信息">  </p><p>现在这个刻度标记很难看到，因为它的颜色与表盘相同。让我们通过<em>Assets&#x2F;Create&#x2F;Material</em>，或者通过项目窗口(Project)的加号按钮和鼠标右键菜单，为它创建一个单独的材质。这时我们获得了一个拥有默认材质的材质球资源。更改它的名字为<em>Hour Indicator</em>。</p><p><img src="https://static.huozk.cn/20220814-7a09348e7be79cdd0e5a0878b4c7df880e54664bd416ed3c49d8a489dd76029b.png" alt="项目窗口中的小时指示器，单列和双列布局。">  </p><p>选中该材质球，并通过点击检查面板(Inspector)的颜色字段(Albedo)，将其反照率改为其他的值。这将打开一个颜色弹出窗口，提供各种方式来选择颜色。这里使用了深灰色，对应于十六进制的494949，这与RGB 0-255模式的73相同。我们不使用alpha透明通道，所以它的值不用关注。可以让其他所有属性保持原样。</p><p><img src="https://static.huozk.cn/20220814-b43a9f4fb861c918e9a865e364d18d5ffbc99f66135abe0e8038bde1e54b4434.png" alt="深灰色的反照率。 ">  </p><details>    <summary>什么是反照率？</summary>    <p>反照率是一个拉丁词，意思是白度。它是一个东西被白光照亮时的颜色。</p></details><p>如何让表盘刻度使用这个材质球。你可以通过把材质球拖到场景(Scene)或层次窗口(Hierarchy)中的物体上来实现。也可以在选择游戏对象时把它拖到检查器窗口(Inspector)的底部，或者改变其<code>MeshRenderer</code>的<code>Materials</code>数组中的第0个元素。</p><p><img src="https://static.huozk.cn/20220814-0cf61417acba764869116d2840e0419357deb9b7fc4867f647f73cc48b12f187.png" alt="深灰色刻度信息。"><br>深灰色刻度信息。</p><h2 id="2-4-十二个小时的刻度"><a href="#2-4-十二个小时的刻度" class="headerlink" title="2.4 十二个小时的刻度"></a>2.4 十二个小时的刻度</h2><p>现在我们可以为每个小时都做一个指示刻度。首先，我们要调整场景中摄像机的方向，使我们能够直视Z轴。通过点击场景视图(Scene)右上角的摄像机轴锥来做到这一点。也可以通过网格工具栏上的按钮将场景网格的轴线改为Z轴。</p><p><img src="https://static.huozk.cn/20220814-11ae7e688187bfae0ce5517510890e557337997b2947a67dc57bf8083d6e9386.jpg" alt="沿着Z轴直视时钟。"><br>沿着Z轴直视时钟。</p><p>复制<em>Hour Indicator 12</em>游戏对象。可以通过<em>Edit&#x2F;Duplicate</em>，或通过指定的键盘快捷键Ctrl+D，或通过层次结构窗口(Hierarchy)中的上下文菜单来完成。复制的对象将出现在层次结构窗口(Hierarchy)中原对象的下面，也是时钟的一个子对象。它的名称被设置为<em>Hour Indicator 12 (1)<em>。把它重命名为</em>Hour Indicator 6</em>，对其位置(Position)Y轴设置为相反的值，使其表示小时刻度6。</p><p><img src="https://static.huozk.cn/20220814-dcbbee1771e4faa1c090b93cc55c8def10e5ae68da2a65a3db91e336547c3430.png" alt="小时6和12的指示器信息。"><br>小时6和12的指示器信息。</p><p>用同样的方法创建小时刻度3和9。在这种情况下，它们的(Position)X轴位置应该是4和-4，Y轴位置应该是0。另外将旋转角度(Rotation)Z轴设置为90°，这样它们就转了四分之一圈。</p><p><img src="https://static.huozk.cn/20220814-66ed1e1bcf5dd67a7f3238f641f849bd2ad67bef519eb73b8775127102e849dd.jpg" alt="四个小时刻度。">  </p><p>然后创建另一个小时刻度12的复制体，这次为小时刻度1。 将其位置(Position)X轴设为2，Y轴设为3.464，其旋转角度(Rotation)Z轴设为-30°。然后将其复制到小时刻度2，交换其位置(Position)X轴和Y轴的值，并将其旋转角度(Rotation)Z轴增加至-60°。</p><p><img src="https://static.huozk.cn/20220814-e5ba9c9e9d6a6e3d2342d477eb4576ee9a5efc5ce55fb138ef4698c1e065880a.jpg" alt="第1和第2小时的指示刻度。">  </p><details>    <summary>这些数字是怎么来的？</summary>    每一个小时沿Z轴顺时针旋转30°。在这种情况下，我们使用负旋转，因为Unity的旋转是逆时针的。我们可以通过三角函数找到第一小时的位置。30°的正弦是$\dfrac{1}{2}$，它的余弦是$\dfrac{\sqrt{\smash[b]{3}}}{2}$。 我们用小时刻度与中心的距离来衡量，即4。 因此，我们最终得到$2\sqrt{\smash[b]{3}}\approx3.464$。 则第2个小时指针的旋转角度应该是60°，对此我们可以简单地变换正弦和余弦。</details><p>复制这两个小时刻度并设置它们的位置Y轴和旋转角度为相反的值，接着创建第4和第5小时的刻度对象。然后对第1、2、4、5小时刻度使用同样的技巧来创建其余的刻度对象，这次要设置它们的位置X轴为相反的值，并再次设置相反的旋转角度。</p><p><img src="https://static.huozk.cn/20220814-754a3c2910ea3282e1244ddf08d6830c30bfe88bfa42de2a712efa382ec34f3a.jpg" alt="所有的表盘刻度 1">  </p><h2 id="2-5-创建指针"><a href="#2-5-创建指针" class="headerlink" title="2.5 创建指针"></a>2.5 创建指针</h2><p>下一步是创建时钟的指针。我们从时针开始。再次复制<em>Hour Indicator 12</em>，并将其命名为<em>Hours Arm</em>。然后创建一个时钟的材质，并让时钟使用它。我们把它设置为纯黑色，十六进制的000000。将时针的比例(Scale)X轴降低到0.3，将其Y轴增加到2.5。然后把它的位置Y轴改为0.75，这样它就指向小时刻度12的位置。但也有一点问题，旋转的时候看起来好像手臂有一点配重。</p><p><img src="https://static.huozk.cn/20220814-6b9e8c0cf76c1a06a84d43dac0af1f4aca05239e4581f98b1183ca920b328cf4.png" alt="时针信息。">  </p><p>指针必须围绕时钟的中心旋转，通过改变它的旋转角度(Rotation)Z轴旋转,但是它却围绕自己的中心旋转。</p><p><img src="https://static.huozk.cn/20220814-f62238da498f775095239b577465d4baee2f6afedf64b3faefec22611d51fc4e.gif" alt="时针围绕自己的中心点旋转。">  </p><p>发生这种情况是因为旋转相对于游戏对象的局部位置(Local Position)而言的。为了创建适合的旋转，我们必须引入一个支点对象，代替该对象进行旋转。因此，创建一个新的空游戏对象，并使其成为时钟(Clock)的子对象。你可以通过层次结构窗口(Hierarchy)中时钟的上下文菜单直接创建这个对象。把它命名为<em>Hours Arm Pivot</em>，并确保它的位置和旋转角度是0，比例是1。</p><p><img src="https://static.huozk.cn/20220814-7efafda35ec9c359271ece644b719622ce55dff957ecf9d24c94ea9c8a1b18c6.png" alt="时针与支点。">  </p><p>现在试着旋转这个支点。如果你通过场景视图(Scene)做这个，确保工具手柄的位置模式被设置为枢轴(旋转轴)而不是中心。</p><p><img src="https://static.huozk.cn/20220814-387977e6766ebd133a521cd3a29820ef83f7dd3c50e1f94e0f44ef1d9e0ccad2.gif" alt="时针围绕支点旋转。 ">  </p><p>复制<em>Hours Arm Pivot</em>两次，创建一个<em>Minutes Arm Pivot</em>和<em>Seconds Arm Pivot</em>。对它们进行相应的重命名，包括支点的子对象。</p><p><img src="https://static.huozk.cn/20220814-aa6ad8dc0c67a04c9aa4df92c5bcfd8207fd1de386e27c4ea870de3adb4bda21.png" alt="所有的指针及其支点对象。 ">  </p><p>分钟指针应该比时针更窄更长，所以将其比例(Scale)X轴设置为0.2，Y轴设置为4，然后将其位置(Position)Y轴增加到1。同时将它的Z轴改为-0.35，以便它位于时针的顶部。注意，这是指针，而不是它的父物体支点。</p><p><img src="https://static.huozk.cn/20220814-3f3c2e3ddc3388dcb119304ca1bf6c1f58cf319e99ec10e746def4b644d6fd8d.jpg" alt="分针的位置。 1"> </p><p>也要调整秒针。这次使用0.1和5作为比例(Scale)的XY值，1.25和-0.45作为位置(Position)YZ轴。</p><p><img src="https://static.huozk.cn/20220814-9eace68b672c11d872b93503f160dcbaa2c616d55713c86a1a8cb9f963f639eb.jpg" alt="秒针的位置。">  </p><p>让我们通过为秒针创建一个单独的材质来使其效果突出。我给它设置一个暗红色，十六进制的B30000。另外，我在场景窗口(Scene)中关闭了网格效果，因为已经完成了时钟的制作。</p><p><img src="https://static.huozk.cn/20220814-43ae2a025e0d1462f727178d437f8f8a9a30a36ebaeaaa9a4ebec8d9a1e3daf0.jpg" alt="三条指针的时钟，最终效果。 1">  </p><p>如果你还没有保存，可以通过<em>File&#x2F;Save</em>或指定的键盘快捷方式Ctrl+S保存更改。</p><p>保持项目资源有序性也是一个好习惯。由于我们有三种材质，需要把它们放在一个材质文件夹(Materials)里，通过<em>Assets&#x2F;Create&#x2F;Folder</em>或通过项目窗口(Project)创建。然后你可以把材质拖到那里面。</p><p><img src="https://static.huozk.cn/20220814-ad60ea159890841df4f5677c16febe418cfb21b8c66178c0fddb9d1a23f75470.jpg" alt="项目窗口中材质文件夹。 1">  </p><h1 id="给时钟添加动画效果"><a href="#给时钟添加动画效果" class="headerlink" title="给时钟添加动画效果"></a>给时钟添加动画效果</h1><p>我们的时钟目前不显示时间，它总是停留在十二点钟。为了使它拥有动画效果，必须给它添加一个自定义行为。可以通过创建一个脚本类型文件来实现。</p><h2 id="3-1-C-脚本资源"><a href="#3-1-C-脚本资源" class="headerlink" title="3.1 C#脚本资源"></a>3.1 C#脚本资源</h2><p>通过<em>Assets&#x2F;Create&#x2F;C#创建</em>一个新的脚本资源到项目中，并命名为Clock。C#是用于Unity脚本的编程语言，发音为C-sharp。我们也需要把它放在一个新的Scripts文件夹里，以保持项目的整洁。</p><p><img src="https://static.huozk.cn/20220814-4d546351d91226b63a81580c641ea19d132768e0d3cdb2087637620e528baf09.png" alt="项目窗口中的脚本文件，放在专门的Sceipts文件夹中。 1">  </p><p>当脚本被选中时，检查器窗口(Inspector)将显示其内容。但是要编辑代码，我们就必须使用代码编辑器。你可以通过按检查器中的<em>Open</em>按钮或双击资脚本资源文件打开编辑。使用哪个应用程序编辑脚本可以通过Unity的首选项(Preferences)进行配置。</p><p><img src="https://static.huozk.cn/20220814-d61f03da1a69f44a7ee61f873073d74cc065c25ea8df066cb8e5eb2e727f2177.png" alt="Clock的C#文件显示信息。 1">  </p><h2 id="3-2-定义一个组件类型"><a href="#3-2-定义一个组件类型" class="headerlink" title="3.2 定义一个组件类型"></a>3.2 定义一个组件类型</h2><p>一旦脚本加载到你的代码编辑器中，就可以删除标准模板代码，我们将从头开始创建组件类型。</p><p>一个空的文件没有定义任何东西。它必须包含我们时钟组件的定义。我们要定义的并不是一个组件的单一实例。相反，我们定义的是被称为时钟的一般类或类型。一旦确定了这一点，我们就可以在Unity中创建多个这样的组件，尽管我们在本教程中只限于一个时钟。</p><p>在C#中，我们定义时钟类型时，首先说明我们正在定义一个类，然后是它的名字。<del>在下面的代码片段中，改变后的代码有一个黄色背景，如果你使用深色网页主题查看本教程，则为暗红色。</del>由于我们从一个空文件开始，它的内容应该是字面上的Clock类，而不是其他东西，不过你可以在字与字之间添加空格和换行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Clock</span></span><br></pre></td></tr></table></figure><details>    <summary>技术上讲，什么是类？</summary>    你可以把类看作是一个蓝图，它可以用来创建驻留在计算机内存中的对象。蓝图定义了这些对象包含哪些数据以及它们具有哪些功能。<br>类也可以定义不属于对象实例的数据和功能，而属于类本身。这通常被用来提供全局可用的功能。我们将使用其中的一些功能，但时钟不会有这些功能。</details><p>因为不想限制其他代码可以访问我们的Clock类型，所以需要在它前面加上public访问修饰符。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span></span><br></pre></td></tr></table></figure><details>    <summary>类的默认访问修饰符是什么？</summary>    如果没有访问修饰符，就好像我们写的是内部类Clock。这将限制为可以对同一程序集的代码访问，当你使用打包在不同程序集的代码时，这就变得很重要了。为了确保它总是可访问，默认情况下是让类成为公共的。</details><p>目前，我们还写入有效的C#语法。如果你要保存文件并回到Unity编辑器，那么编译将会出错且将被记录在Unity控制台窗口(Console)。</p><p>现在表示正在定义一个类型，所以我们必须实际定义它是什么样的。这是由声明后面的一个代码块完成的。代码块的边界用大括号表示。现在没有写任何内容，所以只写{}。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们代码现在是有效的。保存文件并切换回Unity。Unity编辑器将检测到脚本资产已经改变，并触发重新编译。完成后，选择我们的脚本。检查器会通知我们，该资源不包含<code>MonoBehaviour</code>脚本。</p><p><img src="https://static.huozk.cn/20220814-68c5af18aceb984dac04e65c5fca5bff941da7b59a532ff31d01f1fd2e32be6e.png" alt="纯C#脚本信息显示">  </p><p>这意味着我们不能用这个脚本在Unity中创建组件(不能挂在到游戏对象上)。在这一点上，我们的时钟定义了一个基本的C#对象类型。我们的自定义组件类型必须扩展Unity的<code>MonoBehaviour</code>类型，继承其数据和功能。</p><details>    <summary>MonoBehaviour是什么意思？</summary>    意思是，我们可以对自己的组件进行编程，为游戏对象添加自定义行为。这就是行为部分所指的内容。它只是碰巧使用了英式拼写，比较老旧。mono部分指的是对自定义代码的支持被添加到Unity的方式。它使用了Mono开源项目，这是一个.NET框架的多平台运行解决方案。因此，<code>MonoBehaviour</code>，这是一个旧的名字，由于向后兼容的原因，我们坚持使用。</details><p>为了把<code>Clock</code>变成<code>MonoBehaviour</code>的一个子类型，我们必须改变我们的类型声明，使其扩展该类型，这可以在我们的类型名称后面加上冒号，然后是它所扩展的内容。这使得<code>Clock</code>继承了<code>MonoBehaviour</code>类的所有类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>然而，这也会导致编译出错。编译器会抱怨找不到<code>MonoBehaviour</code>类型。是因为该类型包含在一个命名空间中，也就是<code>UnityEngine</code>。要访问它，我们必须使用它的全称，<code>UnityEngine.MonoBehaviour</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">UnityEngine.MonoBehaviour</span> &#123;&#125;</span><br></pre></td></tr></table></figure><details>    <summary>什么是命名空间？</summary>    命名空间就像一个网站的域名，但对于代码来说。就像域名可以有子域名，命名空间可以有子命名空间。最大的区别是，它是反过来写的。因此，代替forum.unity.com的将是com.unity.forum。命名空间是用来组织代码和防止命名冲突的。</details><p>包含<code>UnityEngine</code>代码的程序集是与Unity一起的，你不需要单独上网去获取它。如果你导入了合适的编辑器集成包，代码编辑器使用的项目文件应该可以自动识别。</p><p>在访问Unity类型时，总是要包括<code>UnityEngine</code>的前缀，这是很不方便的。幸运的是，我们可以声明命名空间应该被自动搜索以完成C#文件中的类型名称。这可以通过在文件的顶部添加<code>using UnityEngine;</code>来实现。分号需要用来标记语句的结束。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以将我们的自定义组件添加到Unity中的<em>Clock</em>游戏对象中。这可以通过将脚本资源拖到对象上，或者通过对象检查器(Inspector)底部的添加组件按钮来完成。</p><p><img src="https://static.huozk.cn/20220814-652973b91146191463b602820e429cc5243b10c16f200ee46a6e2fd802b87a78.png" alt="三个指针全部拖拽到脚本定义上"></p><p>请注意，我的教程中的大多数代码类型都可以链接到在线文档。例如，<code>MonoBehaviour</code>是一个链接，可以带你到Unity的该类型的在线脚本API页面。</p><h2 id="3-3-获取一个指针"><a href="#3-3-获取一个指针" class="headerlink" title="3.3 获取一个指针"></a>3.3 获取一个指针</h2><p>要旋转指针，Clock对象需要获取它们。让我们从时针开始。像所有的游戏对象一样，它可以通过调整它的Transform组件来旋转。所以我们必须将指针父物体的Transform组件添加到Clock中。这可以通过在它的代码块中添加一个数据字段来完成，定义为一个名称，后面加一个分号。</p><p>时针支点(Hours Pivot)这个名字对这个字段来说是合适的。然而，名称必须是连贯的。惯例是将字段名的第一个词首字母小写，其他词首字母大写(即驼峰命名法)，然后把它们连在一起。最终将它命名为<em>hoursPivot</em>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">hoursPivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>using语句去哪儿了？</summary>    它还在那里，只是上面没有显示出来。代码片段将只包含现在编辑代码，这样你更能知道编辑的内容。</details><p>我们还必须声明字段的类型，在本例中是<code>UnityEngine.Transform</code>。它必须写在字段名的前面。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transform hoursPivot;</span><br></pre></td></tr></table></figure><p>我们的类现在定义了一个字段，它可以持有对另一个对象的引用，其类型必须是<code>Transform</code>。我们必须确保它持有一个对时钟支点的<code>Transform</code>组件的引用。</p><p>字段默认是私有的，这意味着它们只能被属于时钟(Clock)的代码访问。但是这个类不知道我们的Unity场景，所以没有直接的方法来将字段与正确的对象联系起来。我们可以通过将该字段声明为可序列化来改变这种情况。这意味着当Unity保存场景时，它可以被包含在场景的数据中，它是通过把所有的数据放在一个序列中-Serializing-然后把它写到一个文件中。</p><p>将一个字段标记为可序列化是通过给它附加一个属性来完成的，在这里是<code>SerializeField</code>。它被写在字段声明的前面，包括在方括号中，通常在它上面的一行，但也可以放在同一行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot;</span><br></pre></td></tr></table></figure><details>    <summary>我们不能直接把它变成公共的吗？</summary>    是的，但一般来说，使类字段可以公开访问是不好的形式。以往的经验是，只有当其他类型的C#代码需要访问类的内容时，才将其公开，然后优先选择方法或属性而不是字段。越是不能访问的东西就越容易维护，因为可能直接依赖它的代码越少。在本教程中，我们唯一的C#代码是Clock，所以没有理由将其内容公开。</details><p>一旦这个字段是可序列化的，Unity将检测到这一点，并在我们的Clock游戏对象的Clock组件的检查器窗口(Inspector)中显示它。</p><p><img src="https://static.huozk.cn/20220814-66f363bf7f1e035be22cd6e20b8801ef0000ebce553101dc73ae0aad28987ddf.png" alt="时针支点字段显示。">  </p><p>为了连接他们，将<em>Hours Arm Pivot</em>从层次结构(Hierarchy)中拖到<em>Hours Pivot</em>字段上。或者，使用该字段右侧的圆形按钮，在弹出的列表中搜索该时针支点。在这两种情况下，Unity编辑器都会获取<em>Hours Arm Pivot</em>的<code>Transform</code>组件，并将其引用到我们的字段中。</p><p><img src="https://static.huozk.cn/20220814-4d3702519e411884875e00672ddd8cf430fe0de70d535e0c7cb32d019d9984fc.png" alt="连接状态的时针字段。"> </p><h2 id="3-4-获取所有三条指针"><a href="#3-4-获取所有三条指针" class="headerlink" title="3.4 获取所有三条指针"></a>3.4 获取所有三条指针</h2><p>我们必须为分钟和秒臂枢轴做同样的事情。因此，再给Clock添加两个可序列化的Transform字段，并加上适当的名字。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform minutesPivot;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform secondsPivot;</span><br></pre></td></tr></table></figure><p>可以使这些字段声明变得更简洁吗？，因为它们共享相同的属性、访问修饰符和类型。所以可以合并为由逗号分隔开的字段名列表，跟在属性和类型声明后面。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[SerializeField]</span></span><br><span class="line"><span class="comment">//Transform minutesPivot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[SerializeField]</span></span><br><span class="line"><span class="comment">//Transform secondsPivot;</span></span><br></pre></td></tr></table></figure><details>    <summary>//是做什么的？</summary>    双斜线表示一个注释。它们之后直到行尾的所有文本都会被编译器忽略。如果需要的话，它可以用来添加文本以说明代码。我也用它来表示已经被删除的代码。除此之外，被删除的代码有一条线穿过它。</details><p>在编辑器中把另外两个指针支点也挂上。</p><p><img src="https://static.huozk.cn/20220814-51f0e91864bcd62544af15f427a71f5dd0e22fab557ced1d3ee4f8c19af8a758.png" alt="所有三条指针都处于连接状态。">  </p><h2 id="3-5-唤醒"><a href="#3-5-唤醒" class="headerlink" title="3.5 唤醒"></a>3.5 唤醒</h2><p>现在，我们可以访问指针支点了，下一步是旋转它们。要做到这一点，我们需要时钟(Clock)执行一些代码。通过在类中添加一个代码块来完成，也就是所谓的方法。这个代码块的前缀是一个名字，按照惯例，这个名字是大写的。我们将它命名为<code>Awake</code>，说明这些代码应该在脚本被唤醒时执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField］</span></span><br><span class="line"><span class="meta">Transform hoursPivot, minutesPivot, secondsPivot;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">Awake &#123;&#125;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></table></figure><p>方法有点像数学函数，例如$\textit{f}(x) &#x3D; 2x+3$。该函数需要一个数字-由变量参数表示的$x$-将其加倍，然后再加上3。它对一个单一的数字进行操作，其结果也是一个单一的数字。在方法的情况下，它更像$\textit{f}(p)&#x3D;c$是其中$p$代表输入参数，而代表它所执行的任何代码。</p><p>像数学函数一样，方法可以产生一个结果，但这并不是必须的。我们必须声明结果的类型–就像它是一个字段一样，这里通过写成<code>void</code>来表示没有结果。在我们的例子中，我们只是想执行一些代码，而不提供一个结果值，所以使用<code>void</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Awake &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们也不需要任何输入数据。然而，我们仍然要定义方法的参数，作为圆括号之间的逗号分隔的列表。在我们的例子中，它只是一个空列表。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span> ()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们现在有了一个有效的方法，尽管它还没有做任何事情。就像Unity检测到我们的字段一样，它也检测到了这个<code>Awake</code>方法。当一个组件有一个<code>Awake</code>方法时，Unity会在该组件被唤醒时调用该方法。这发生在它被创建或在游戏模式下被加载之后。我们目前处于编辑模式，所以这还没有发生。</p><details>    <summary>Awake不是必须是公共的吗？</summary>    Awake和其他一些方法被认为是特殊的Unity事件方法。不管我们如何声明它们，Unity引擎会找到它们并在适当的时候调用它们。这发生在托管的.NET环境之外。详细内容可以查阅Unity脚本生命周期。</details><p>请注意，<code>Awake</code>和其他特殊的Unity事件方法在<del>我的教程中有粗体字</del>，并链接到其在线Unity脚本API页面。</p><h2 id="3-6-通过代码进行旋转"><a href="#3-6-通过代码进行旋转" class="headerlink" title="3.6 通过代码进行旋转"></a>3.6 通过代码进行旋转</h2><p>为了旋转指针，我们必须创建一个新的旋转角度。我们可以通过给<code>Transform</code>的<code>localRotation</code>属性分配一个新的旋转角度来旋转它。</p><details>    <summary>什么是属性？</summary>    属性是一种方法，它假装是一个字段。它可能是只读或只写的。C#的惯例是将属性大写，但Unity的代码并没有这样做。</details><p>虽然<code>Transform</code>组件的旋转角度在检查器(Inspector)中是用欧拉角(Euler)定义的，单位是每轴度数，但在代码中我们必须用四元数(Quaternion)来设置。</p><details>    <summary>什么是四元数？</summary>    四元数是基于复数的，用来表示三维旋转。虽然比单独的X、Y和Z旋转角的组合更难理解，但它们有一些有用的特性。例如，它们不会受到万向节锁的影响。</details><p>通过调用<code>Quaternion.Euler</code>方法创建一个基于欧拉角的四元数。具体做法是在<code>Awake</code>中写入，然后用分号来结束语句。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">Quaternion.Euler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法有用于描述所需旋转的参数。在这种情况下，我们将提供一个逗号分隔的包含三个参数的列表，都在圆括号之间，在方法名称之后。我们为X、Y和Z的旋转轴提供三个数值。前两个使用0，Z旋转角度使用-30。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-30</span>);</span><br></pre></td></tr></table></figure><p>这个调用的结果是一个四元数结构值，包含围绕Z轴的30°顺时针旋转，与我们时钟上的小时数相匹配。</p><details>    <summary>什么是结构？</summary>    结构是结构体的简称，是一种蓝图，就像一个类。不同的是，无论它创建的是什么，都被视为一个简单的值，如整数或颜色，而不是一个对象。它没有身份感。定义自己的结构与定义类的工作原理相同，只是你写的是结构而不是类。</details><p>为了将这个旋转应用于时针，使用&#x3D;赋值语句将<code>Quaternion.Euler</code>的结果分配给<code>hoursPivots.localRotation</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-30</span>);</span><br></pre></td></tr></table></figure><details>    <summary>localRotation和Rotation之间有什么区别？</summary>    <code>localRotation</code>属性表示<code>Transform</code>组件单独描述的旋转，因此它是一个相对于其父级的旋转角度。这是你在其检查器(Inspector)中看到的旋转角度。相比之下，<code>Rotation</code>属性表示世界空间中的最终旋转角度，将整个对象的层次结构都考虑在内。如果我们将时钟作为一个整体进行旋转，设置该属性会产生奇怪的结果。因为该属性在对时钟的旋转角度进行补偿时，指针会忽略这一点。</details><details>    <summary>难道不应该有一个警告说hoursPivot从未被初始化吗？</summary>    编译器可以检测到没有任何代码为该字段赋值，确实可以发出这样的警告，因为它不知道我们通过Unity的检查器(Inspector)设置了它。然而，这个警告在默认情况下是被关闭。可以通过项目设置(Project Settings)来控制开关。在<em>Player/Other Settings/Script Compilation</em>下有一个抑制普通警告的切换键。它关闭了关于未初始化和未使用的私有字段的警告。</details><p>现在编辑器中进入播放模式。你可以通过 <em>Edit&#x2F;Play，</em> 指定的键盘快捷键或按编辑器窗口顶部中间的播放按钮来实现。Unity将把焦点切换到游戏窗口(Game)，它将渲染场景中主摄像机看到的所有东西。时钟(Clock)组件将被唤醒，时钟(Clock)将被设置为一点钟状态。</p><p><img src="https://static.huozk.cn/20220814-f49558a4f07eecf9b16ec8fd985831e2fb69035094b69b916fb7f594f1f6b80c.jpg" alt="播放模式下，总是保持在1点钟状态。">  </p><p>如果摄像机没有聚焦在时钟上，你可以移动它使时钟变得可见，但请记住，当退出游戏模式时，场景会被重置，所以你在游戏模式(Play)中对场景所做的任何改变都不会持续。但对资源来说不是这样的，它们的改变总是会被保存的。你也可以在游戏模式(Play)中打开场景窗口(Scene)，甚至是多个场景(Scene)和游戏窗口(Play)。在继续之前退出游戏模式(Play)。</p><h2 id="3-7-获取当前的时间"><a href="#3-7-获取当前的时间" class="headerlink" title="3.7 获取当前的时间"></a>3.7 获取当前的时间</h2><p>下一步是弄清我们醒来时的当前时间。我们可以使用<code>DateTime</code>结构来访问我们正在运行的设备的系统时间。<code>DateTime</code>并不是一个统一的类型，它可以在<code>System</code>命名空间中找到。它是.NET框架核心功能的一部分，Unity就是用它来支持脚本的。</p><p><code>DateTime</code>有一个<code>Now</code>属性，产生一个包含当前系统日期和时间的<code>DateTime</code>值。为了检查它是否正确，我们将在<code>Awake</code>开始时，通过把它传递给<code>Debug.Log</code>方法来实现把它记录到控制台(Control)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clock</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">Debug.Log(DateTime.Now);</span><br><span class="line">hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们每次进入播放模式都会得到一个时间戳的记录。你可以在控制台窗口(Control)和编辑器窗口底部的状态栏中看到它。</p><h2 id="3-8-转动指针"><a href="#3-8-转动指针" class="headerlink" title="3.8 转动指针"></a>3.8 转动指针</h2><p>我们越来越接近一个可以工作的时钟了。让我们再次从小时开始。<code>DateTime</code>有一个<code>Hour</code>属性，可以获得<code>DateTime</code>值的小时部分。在当前的时间戳上调用这个属性，我们就可以得到当前的小时时间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(DateTime.Now.Hour);</span><br></pre></td></tr></table></figure><p>因此，为了让时针显示出当前的小时，我们必须将-30°的旋转角度值乘以当前的小时。乘法是用星号*字符完成的。我们也不再需要记录当前时间，现在可以去掉这个语句。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="comment">//Debug.Log(DateTime.Now.Hour);~~</span></span><br><span class="line">hoursPivot.localRotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-30</span> * DateTime.Now.Hour);</span><br></pre></td></tr></table></figure><p><img src="https://static.huozk.cn/20220814-29154618857e1bbba5f2f0ba25238d0fad46387a784be121c082f384b0128f84.jpg" alt="播放模式下，时针指定的方向，由于我是零点设置的，所以跟原来一样的效果。 1">  </p><p>为了明确我们是从小时时间到角度的转换，我们可以定义一个包含转换系数的<code>hoursToDegrees</code>字段。<code>Quaternion.Euler</code>的角度被定义为浮点值，所以我们将使用浮点类型。我们已经知道了这个数字，可以立即把它作为字段声明的一部分。然后与<code>DateTime</code>中的值字段相乘，而不是与<code>Awake</code>中的字面数字<code>-30</code>相乘。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> hoursToDegrees = <span class="number">-30</span>。</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0</span>, <span class="number">0</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>什么是浮点数？</summary>    计算机不能存储所有的数字，它们必须可以在其二进制存储器中被表示，而二进制存储器是由不是0就是1的比特组成，这使得许多数字不可能在有限的内存大小内精确地存储；例如$\dfrac{1}{3}$，就像我们不能精确地用十进制符号来写这个数字一样。我们能做的最好的事情就是写0.3333333，然后在某个点上停止。<br>    假设我们决定在点的后面最多写三位数，而在点的前面只写一位数。那么$\dfrac{1}{3}$就近似于0.333。如果我们要用$\dfrac{1}{3}$除以100，那么我们就会被迫写成0.003，这意味着我们失去了两位数的精度。为了提高小数值的精度，让我们添加一个单独的指数，表示我们数字的数量级。那么$0.333\times10^{-2}$可以表示$\dfrac{1}{3}$除以100，而不会失去有意义的数字。而且我们可以用$0.333\times10^{2}$来表示100的乘法，同时在点的前面只保留一个数字。因此，点可以被认为是浮动的，因为它并不指定一个固定的数量级。这使得我们可以只用几个数字来表示大量的数字。<br>    浮点数在计算机中的工作原理是一样的，只是它们使用二进制而不是十进制的数字，而且还必须表示一些特殊的数值，如无穷大和非数字。一个浮点数就是这样一个存储在四个字节中的值，这意味着它有32位。</details><p>如果我们声明一个没有后缀的整数，那么它被认为是一个整数，这是一个不同的值类型。尽管编译器会自动进行转换，但让我们通过给它们加上f后缀来明确说明我们所有的数字都是float类型的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> hoursToDegrees = <span class="number">-30f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">hoursPivot.localRotation = </span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每小时的度数总是相同的。我们可以通过在<code>hoursToDegrees</code>的声明中加入<code>const</code>前缀来执行这一点。这将它变成一个常量而不是一个字段。</p><details>    <summary>const值有什么特殊之处？</summary>    const关键字表示一个值永远不会改变，不需要成为一个字段。相反，它的值将在编译过程中被计算出来，并被替换为常量的所有用法。这只适用于像数字这样的原始类型。</details><p>让我们使用<code>DateTime</code>的适当属性，对另外两个指针进行同样的处理。一分钟和一秒钟都用负六度的旋转来表示。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hoursToDegrees = <span class="number">-30f</span>, minutesToDegrees = <span class="number">-6f</span>, secondsToDegrees = <span class="number">-6f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line">Transform hoursPivot, minutesPivot, secondsPivot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * DateTime.Now.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * DateTime.Now.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * DateTime.Now.Second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://static.huozk.cn/20220814-ec4d63a7c396d582136103b9350c0a91a95013a848485fae8499b3bc9dea04f5.jpg" alt="根据当前时间显示指针">  </p><p>我们使用了三次<code>DateTime.Now</code>，来检索小时、分钟和秒。每一次我们都要重新访问这个属性，这需要一些间隔，理论上可能会导致不同的时间值。为了确保这种情况不会发生，我们应该只检索一次时间。可以通过在方法内部声明一个变量并将时间赋值给它，然后在之后使用这个值来做到这一点。让我们把它命名为<code>time</code>。</p><details>    <summary>什么是变量？</summary>    变量的作用类似于字段，只不过它只在方法执行时存在。它属于这个方法，而不是属于这个类。</details><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">DateTime time = DateTime.Now;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.Second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在变量的情况下，可以省略类型声明，用<code>var</code>关键字来代替。这可以缩短代码，但只有当变量的类型可以从声明时分配给它的内容中推断出来时才可以使用。另外，我倾向于只在语句中明确提到类型时才这样做，这里就属于这种情况。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = DateTime.Now;</span><br></pre></td></tr></table></figure><h2 id="3-9-给指针做动画"><a href="#3-9-给指针做动画" class="headerlink" title="3.9 给指针做动画"></a>3.9 给指针做动画</h2><p>当我们进入播放模式时会得到了当前的时间，但之后，时钟仍然保持不动。为了保持时钟与当前时间的同步，将我们的<code>Awake</code>方法的名字改为<code>Update</code>。这是另一个特殊的事件方法，只要我们保持在游戏模式中，每一帧都会被Unity调用，而不是只调用一次。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line"><span class="keyword">var</span> time = DateTime.Now;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.Hour);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.Minute);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.Second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://static.huozk.cn/20220814-1092f9e5eda796a113b0355e5d93fd2ccde8dc6ef40dae4a1a92f16656acf6d3.gif" alt="不连贯时针动画">  </p><details>    <summary>什么是一帧？</summary>    在游戏模式下，Unity不断地从主摄像机的视角渲染场景。一旦渲染完成，结果就会呈现在显示屏上。然后显示器将显示该帧，直到得到下一帧。在渲染新的一帧之前，一切都会被更新。所以Unity经历了一个更新、渲染、更新、渲染等的序列。通常情况下，一个单一的更新步骤和渲染一次场景被认为是一个单一的帧，尽管在现实中，时间是比较复杂的。</details><p>请注意，我们的时钟组件在检查器(Inspector)中的名字前面有一个切换按钮。这允许我们禁用它，可以防止Unity调用其更新方法。</p><p><img src="https://static.huozk.cn/20220814-ba36c650471fd0a12daa3f26fd9404a1ae2b3904bc4435def84bd2575ce3e53e.png" alt="可以通过按钮暂停脚本使用">  </p><h2 id="3-10-持续旋转"><a href="#3-10-持续旋转" class="headerlink" title="3.10 持续旋转"></a>3.10 持续旋转</h2><p>我们的时钟指针准确地表明了当前的小时、分钟和秒。它的行为就像一个数字钟，离散的，但有指针。通常情况下，通过提供时间的模拟表示，时钟有缓慢连续旋转的指针。让我们修改我们的方法，使时钟成为真实模拟状态。</p><p><code>DateTime</code>不包含小数点数据。幸运的是，它确实有一个<code>TimeOfDay</code>属性。这给了我们一个<code>TimeSpan</code>值，它包含了我们需要格式的数据，通过它的<code>TotalHours, TotalMinutes, 和TotalSeconds</code>属性。</p><p>首先，从<code>DateTime.Now</code>中获取<code>TimeOfDay</code>结构值，并将其存储在变量中。由于该语句中没有提到<code>TimeSpan</code>的类型，我将使变量的类型更明确。然后调整我们用来旋转指针的属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">TimeSpan time = DateTime.Now.TimeOfDay;</span><br><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * time.TotalHours);</span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * time.TotalMinutes);</span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * time.TotalSeconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将导致编译器错误，告知我们不能从双数转换为浮点数。发生这种情况是因为<code>TimeSpan</code>属性产生的值是双精度浮点类型，即所谓的<code>double</code>。这些值提供了比浮点值更高的精度，但是Unity的代码只适用于单精度的浮点值。</p><details>    <summary>单精度够吗？</summary>    对于大多数游戏来说，是的。当处理非常大的距离或比例差异时，这就成为一个问题。那么你就必须使用一些技巧，比如传输或对于相机的渲染来保持活动区域在世界原点附近。虽然使用双精度可以解决这个问题，但它也会使所涉及的数字的内存大小增加一倍，从而导致其他性能问题。游戏引擎通常使用单精度浮点值，而GPU也是如此。</details><p>我们可以通过强制地将双数转换为浮点数来解决这个问题。这个过程被称为转换，通过在要转换的值前面的圆括号中写上新的类型来完成。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hoursPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, hoursToDegrees * (<span class="built_in">float</span>)time.TotalHours);</span><br><span class="line"></span><br><span class="line">minutesPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, minutesToDegrees * (<span class="built_in">float</span>)time.TotalMinutes);</span><br><span class="line"></span><br><span class="line">secondsPivot.localRotation =</span><br><span class="line">Quaternion.Euler(<span class="number">0f</span>, <span class="number">0f</span>, secondsToDegrees * (<span class="built_in">float</span>)time.TotalSeconds);</span><br></pre></td></tr></table></figure><p><img src="https://static.huozk.cn/20220814-f97ced0a10c8c397c2d393016a2749eb2aea30e1969eeed3bed5f8b5d3f5387a.gif" alt="最终效果">  </p><p>现在你知道了在Unity中创建对象和编写代码的基本原理。下一个教程是建立一个图形(Graph)。</p><blockquote><p>源码仓库地址：<a href="https://github.com/huozk0804/UnityTutorialsOfBasics">https://github.com/huozk0804/UnityTutorialsOfBasics</a><br>该文章原文地址：<a href="https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/">https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/</a><br>授权文件：<a href="https://huozk.cn/2022/08/cd3d674a/">https://huozk.cn/2022/08/cd3d674a/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用简单的对象构建一个时钟。&lt;/p&gt;
&lt;p&gt;写一个C#脚本。&lt;/p&gt;
&lt;p&gt;转动时钟的指针以显示时间。&lt;/p&gt;
&lt;p&gt;对钟臂进行动画处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是关于学习使用Unity基础知识的系列教程中的第一个教程。在本教程中，我们将创建一个简单的时钟，并对脚本组件进行编程，让它显示当前时间。你不需要有任何使用Unity编辑器的经验，但需要你有一些使用多窗口编辑器应用程序的经验。&lt;/p&gt;
&lt;p&gt;在我所有教程的底部，你可以找到教程许可证的链接，包含完成的教程项目的资源库，以及教程页面的PDF版本。&lt;/p&gt;
&lt;p&gt;本教程是用Unity 2020.3.6f1制作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.huozk.cn/20220814-4585c7a8fa39ec03fbfc78ffaccc5b41555bc348a1e5f61f605b11e12c84ccca.jpg&quot; alt=&quot;这是时钟的最终效果&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Creating-a-Project&quot;&gt;&lt;a href=&quot;#Creating-a-Project&quot; class=&quot;headerlink&quot; title=&quot;Creating a Project&quot;&gt;&lt;/a&gt;Creating a Project&lt;/h1&gt;&lt;p&gt;在开始使用Unity编辑器之前，我们必须首先创建一个项目。&lt;/p&gt;
&lt;h2 id=&quot;1-1-新项目&quot;&gt;&lt;a href=&quot;#1-1-新项目&quot; class=&quot;headerlink&quot; title=&quot;1.1 新项目&quot;&gt;&lt;/a&gt;1.1 新项目&lt;/h2&gt;&lt;p&gt;当你打开Unity时，你会看到Unity Hub。这是一个启动器和安装程序，在这里你可以创建或打开项目，以及安装管理Unity版本，并做一些其他事情。如果你没有安装Unity2020.3或更高版本，现在就请添加它吧。&lt;/p&gt;
&lt;details&gt;
    &lt;summary&gt;哪些Unity版本是合适的？&lt;/summary&gt;
    &lt;p&gt;Unity每年会发布很多个新版本。其中有两个平行版本发布时间表。最稳定和安全的是LTS版本。LTS代表长期支持，在Unity说明下是支持两年。&lt;/p&gt;
    &lt;p&gt;我的教程坚持使用LTS版本，其中2020.3是最新版本。本教程特别使用2020.3.6。版本号的第三部分表示补丁版本。补丁版本包含错误修复，很少有新功能。另一个f1后缀表示官方最终版本。任何2020.3版本都可以用于本教程。&lt;/p&gt;
&lt;/details&gt;</summary>
    
    
    
    <category term="Catlike Coding Unity Tutorial" scheme="http://huozk.cn/categories/Catlike-Coding-Unity-Tutorial/"/>
    
    
    <category term="unity-base" scheme="http://huozk.cn/tags/unity-base/"/>
    
  </entry>
  
  <entry>
    <title>Catlike Coding Unity Tutorial License</title>
    <link href="http://huozk.cn/2022/03/catlike-coding-unity-tutorial-license/"/>
    <id>http://huozk.cn/2022/03/catlike-coding-unity-tutorial-license/</id>
    <published>2022-03-01T01:46:42.000Z</published>
    <updated>2023-05-19T01:49:19.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unity-Tutorial-License"><a href="#Unity-Tutorial-License" class="headerlink" title="Unity Tutorial License"></a>Unity Tutorial License</h2><blockquote><p>基于MIT-0和CC BY-NC-SA 4.0。</p></blockquote><p>所有Catlike Coding Unity教程都有两个许可证，一个是代码和资产的许可证，另一个是教程本身的许可证。</p><h2 id="代码和资源许可证"><a href="#代码和资源许可证" class="headerlink" title="代码和资源许可证"></a>代码和资源许可证</h2><p>下面的MIT-0许可证适用于所有代码、纹理和其他Unity项目文件，作为教程的一部分提供。它使用MIT许可证，没有归属权。这意味着你可以不受限制地使用这些内容。你不需要在你的项目中引用一个许可证文件。你也不必把这些归功于我，但如果你想这样做，我肯定会很感激。</p><h3 id="1-1-MIT无署名-MIT-0"><a href="#1-1-MIT无署名-MIT-0" class="headerlink" title="1.1 MIT无署名(MIT-0)"></a>1.1 MIT无署名(MIT-0)</h3><p>Copyright 2022 Jasper Flick</p><p>特此允许任何获得本软件和相关文档文件（”软件”）副本的人无限制地处理本软件，包括但不限于拥有使用、复制、修改、合并、出版、分发、许可或销售本软件副本的权利，以及允许使用本软件的人也这样做。</p><p>声明：本软件 “按原样 “提供，没有任何明示或暗示的保证，包括但不限于对适销性、特定用途的适用性和非侵权性的保证。在任何情况下，作者或版权持有人都不对，无论是在合同、侵权行为或其他诉讼中，由本软件或本软件的使用及其他交易引起的与之相关造成的任何索赔、损害或其他责任负责。</p><h3 id="1-2-给予信用"><a href="#1-2-给予信用" class="headerlink" title="1.2 给予信用"></a>1.2 给予信用</h3><p>如果你想在你的作品中引用我的名字，你可以通过提及我Jasper Flick或Catlike Coding来实现。如果你想在你的作品中提到我Jasper Flick或<a href="https://catlikecoding.com/">Catlike Coding</a>的话，可以提供本网站的链接。</p><h2 id="教程许可"><a href="#教程许可" class="headerlink" title="教程许可"></a>教程许可</h2><p>署名-非商业性-相同方式共享4.0国际（CC BY-NC-SA 4.0）许可证适用于我所有的教程。我指的是实际的教程，而不是它们演示的内容。它涵盖了文字、截图、图表、动画、PDF和其他媒体，这些共同构成了一个教程。它不适用于代码和资产，但它确实适用于表现形式：添加和删除的风格等等。</p><h3 id="2-1-翻译我的教程"><a href="#2-1-翻译我的教程" class="headerlink" title="2.1 翻译我的教程"></a>2.1 翻译我的教程</h3><p>只要你遵守上述的CC BY-NC-SA 4.0许可证，你可以翻译我的作品并将其存放在任何地方。但是我不能为翻译的质量作担保。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Unity-Tutorial-License&quot;&gt;&lt;a href=&quot;#Unity-Tutorial-License&quot; class=&quot;headerlink&quot; title=&quot;Unity Tutorial License&quot;&gt;&lt;/a&gt;Unity Tutorial License&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;基于MIT-0和CC BY-NC-SA 4.0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有Catlike Coding Unity教程都有两个许可证，一个是代码和资产的许可证，另一个是教程本身的许可证。&lt;/p&gt;
&lt;h2 id=&quot;代码和资源许可证&quot;&gt;&lt;a href=&quot;#代码和资源许可证&quot; class=&quot;headerlink&quot; title=&quot;代码和资源许可证&quot;&gt;&lt;/a&gt;代码和资源许可证&lt;/h2&gt;&lt;p&gt;下面的MIT-0许可证适用于所有代码、纹理和其他Unity项目文件，作为教程的一部分提供。它使用MIT许可证，没有归属权。这意味着你可以不受限制地使用这些内容。你不需要在你的项目中引用一个许可证文件。你也不必把这些归功于我，但如果你想这样做，我肯定会很感激。&lt;/p&gt;
&lt;h3 id=&quot;1-1-MIT无署名-MIT-0&quot;&gt;&lt;a href=&quot;#1-1-MIT无署名-MIT-0&quot; class=&quot;headerlink&quot; title=&quot;1.1 MIT无署名(MIT-0)&quot;&gt;&lt;/a&gt;1.1 MIT无署名(MIT-0)&lt;/h3&gt;&lt;p&gt;Copyright 2022 Jasper Flick&lt;/p&gt;
&lt;p&gt;特此允许任何获得本软件和相关文档文件（”软件”）副本的人无限制地处理本软件，包括但不限于拥有使用、复制、修改、合并、出版、分发、许可或销售本软件副本的权利，以及允许使用本软件的人也这样做。&lt;/p&gt;
&lt;p&gt;声明：本软件 “按原样 “提供，没有任何明示或暗示的保证，包括但不限于对适销性、特定用途的适用性和非侵权性的保证。在任何情况下，作者或版权持有人都不对，无论是在合同、侵权行为或其他诉讼中，由本软件或本软件的使用及其他交易引起的与之相关造成的任何索赔、损害或其他责任负责。&lt;/p&gt;
&lt;h3 id=&quot;1-2-给予信用&quot;&gt;&lt;a href=&quot;#1-2-给予信用&quot; class=&quot;headerlink&quot; title=&quot;1.2 给予信用&quot;&gt;&lt;/a&gt;1.2 给予信用&lt;/h3&gt;</summary>
    
    
    
    <category term="Catlike Coding Unity Tutorial" scheme="http://huozk.cn/categories/Catlike-Coding-Unity-Tutorial/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity项目架构设计与开发管理</title>
    <link href="http://huozk.cn/2022/01/unity-manager-intro/"/>
    <id>http://huozk.cn/2022/01/unity-manager-intro/</id>
    <published>2022-01-19T01:53:35.000Z</published>
    <updated>2023-05-19T02:00:21.986Z</updated>
    
    <content type="html"><![CDATA[<p>笔者是观摩刘钢先生讲解的<a href="https://v.qq.com/x/page/d016340mkcu.html">Unity项目架构设计与开发管理</a>后所总结记录的。</p><h2 id="EmptyGo"><a href="#EmptyGo" class="headerlink" title="EmptyGo"></a>EmptyGo</h2><p>将所有的代码放到一个空的游戏对象中；<br>使用 <code>GameObject.Find()</code> 来找到目标进行使用。<br>架构设计的雏形实现，缺点是当我们的项目越来越大的时候难以灵活管理；不适合大型项目。</p><h2 id="Simple-GameManager"><a href="#Simple-GameManager" class="headerlink" title="Simple GameManager"></a>Simple GameManager</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameManager.Instance.playSound(<span class="string">&quot;menu&quot;</span>);</span><br></pre></td></tr></table></figure><p>优点是： 是把EmptyGO做成一个单例来使用；比较适合小型项目；空物体进行全局引用。 缺点是： 把所有的逻辑都放在一个脚本中，不利于编译；而且会造成单一文件过于庞大；NO 即插即用。</p><h2 id="Manager-Of-Managers"><a href="#Manager-Of-Managers" class="headerlink" title="Manager Of Managers"></a>Manager Of Managers</h2><p>类似于分级结构，各司其职；比如音频管理，场景管理，关卡管理等，每一个都是一个单例脚本，配合使用。结构相对清晰。</p><ul><li>MainManager</li><li>EventManager：消息传递管理</li><li>AudioManager：音效管理</li><li>GUIManager：图形视图管理</li><li>PoolManager：GO管理</li><li>LevelManager： 关卡管理</li><li>GameManager：核心机制管理</li><li>SaveManager：游戏进度管理</li><li>MenuManager：菜单行为动画管理</li><li>…</li></ul><h2 id="MVCS（StrangeIOC）"><a href="#MVCS（StrangeIOC）" class="headerlink" title="MVCS（StrangeIOC）"></a>MVCS（StrangeIOC）</h2><p><img src="https://static.huozk.cn/20220805-c9b698b02061b94348a99223603d3f67a303aecd808fa203be7e055d417b37b6.jpg" alt="Unity3D-StrongeIOC框架结构图">  </p><p>Strange是一个超轻量级且高度可扩展的控制反转控制（IoC）框架，专为C＃和Unity编写。 它包含以下功能，其中大部分是可选的：</p><ul><li>一个核心绑定框架，几乎可以让你将一个或多个任何东西绑定到一个或多个其他任何东西。</li><li>依赖注入</li><li>反射绑定显著降低了采用反射效率的开销</li><li>共享事件系统，EventDispatcher 和 Signals。</li><li>MonoBehaviour 调配</li><li>可选的MVCS（模型&#x2F;视图&#x2F;控制器&#x2F;服务）结构</li><li>…</li></ul><p>这个框架的想法很有意思；可以研究一下它的原理即源码。 地址：<a href="https://github.com/strangeioc/strangeioc">https://github.com/strangeioc/strangeioc</a></p><h2 id="MVVM（uFrame）"><a href="#MVVM（uFrame）" class="headerlink" title="MVVM（uFrame）"></a>MVVM（uFrame）</h2><p><img src="https://static.huozk.cn/20220805-d667d7787dff6b65113088cd5c2f4ffc978de68a89d11cbc26b11d6e6456d5c1.jpg" alt="Unity3D-uFrame框架结构">  </p><p>uFrame 是为 Unity Engine 设计的 MVVM &#x2F; MV * 框架。它配备了大量功能，包括图形界面 &#x2F; 图表引擎，可生成代码甚至处理一些重新分解。图形界面显著提高所有团队成员开发和实施一致编码模型的效率。随着微软全息镜头的崛起和Unity的跨平台功能，uFrame 是构建下一个大型应用程序或游戏的终极解决方案。 包含以下功能：</p><ul><li>高质量的图形引擎</li><li>可编辑的代码生成模板</li><li>UGUI绑定</li><li>IOC &#x2F;依赖注入</li><li>完整的MV *实现 – 事件聚合</li><li>场景管理（将场景加载为具有附加加载的预制件）</li><li>在极大型项目上测试运行</li><li>开源框架</li><li>…</li></ul><h2 id="实体组件系统（ECS）"><a href="#实体组件系统（ECS）" class="headerlink" title="实体组件系统（ECS）"></a>实体组件系统（ECS）</h2><p>在2018年，Unity又重点推荐ECS；ECS是一种编写代码的方式，专注于您正在解决的实际问题：组成游戏的数据和行为。其中心为Entity，Component，System。除了出于设计原因更好地接近游戏编程之外，使用ECS可以使您更好的利用Unity的C＃job系统和Burst Compiler，充分利用当今的多核处理器。</p><ul><li>Entity 是实例,作为承载组件的载体,也是框架中维护对象的实体.</li><li>Component 只包含数据,具备这个组件便具有这个功能.</li><li>System 作为逻辑维护,维护对应的组件执行相关操作.</li></ul><p>而且使用ECS，可以让你从面向对象转向数据导向设计，这意味着重用代码更容易，并且更容易让其他人掌握并做出贡献。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔者是观摩刘钢先生讲解的&lt;a href=&quot;https://v.qq.com/x/page/d016340mkcu.html&quot;&gt;Unity项目架构设计与开发管理&lt;/a&gt;后所总结记录的。&lt;/p&gt;
&lt;h2 id=&quot;EmptyGo&quot;&gt;&lt;a href=&quot;#EmptyGo&quot; class=&quot;headerlink&quot; title=&quot;EmptyGo&quot;&gt;&lt;/a&gt;EmptyGo&lt;/h2&gt;&lt;p&gt;将所有的代码放到一个空的游戏对象中；&lt;br&gt;使用 &lt;code&gt;GameObject.Find()&lt;/code&gt; 来找到目标进行使用。&lt;br&gt;架构设计的雏形实现，缺点是当我们的项目越来越大的时候难以灵活管理；不适合大型项目。&lt;/p&gt;
&lt;h2 id=&quot;Simple-GameManager&quot;&gt;&lt;a href=&quot;#Simple-GameManager&quot; class=&quot;headerlink&quot; title=&quot;Simple GameManager&quot;&gt;&lt;/a&gt;Simple GameManager&lt;/h2&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GameManager.Instance.playSound(&lt;span class=&quot;string&quot;&gt;&amp;quot;menu&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;优点是： 是把EmptyGO做成一个单例来使用；比较适合小型项目；空物体进行全局引用。 缺点是： 把所有的逻辑都放在一个脚本中，不利于编译；而且会造成单一文件过于庞大；NO 即插即用。&lt;/p&gt;
&lt;h2 id=&quot;Manager-Of-Managers&quot;&gt;&lt;a href=&quot;#Manager-Of-Managers&quot; class=&quot;headerlink&quot; title=&quot;Manager Of Managers&quot;&gt;&lt;/a&gt;Manager Of Managers&lt;/h2&gt;&lt;p&gt;类似于分级结构，各司其职；比如音频管理，场景管理，关卡管理等，每一个都是一个单例脚本，配合使用。结构相对清晰。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MainManager&lt;/li&gt;
&lt;li&gt;EventManager：消息传递管理&lt;/li&gt;
&lt;li&gt;AudioManager：音效管理&lt;/li&gt;
&lt;li&gt;GUIManager：图形视图管理&lt;/li&gt;
&lt;li&gt;PoolManager：GO管理&lt;/li&gt;
&lt;li&gt;LevelManager： 关卡管理&lt;/li&gt;
&lt;li&gt;GameManager：核心机制管理&lt;/li&gt;
&lt;li&gt;SaveManager：游戏进度管理&lt;/li&gt;
&lt;li&gt;MenuManager：菜单行为动画管理&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;MVCS（StrangeIOC）&quot;&gt;&lt;a href=&quot;#MVCS（StrangeIOC）&quot; class=&quot;headerlink&quot; title=&quot;MVCS（StrangeIOC）&quot;&gt;&lt;/a&gt;MVCS（StrangeIOC）&lt;/h2&gt;</summary>
    
    
    
    <category term="Unity" scheme="http://huozk.cn/categories/Unity/"/>
    
    
    <category term="unity-framework" scheme="http://huozk.cn/tags/unity-framework/"/>
    
  </entry>
  
  <entry>
    <title>保持Unity项目结构清晰的7种方法</title>
    <link href="http://huozk.cn/2021/12/project-list-clear/"/>
    <id>http://huozk.cn/2021/12/project-list-clear/</id>
    <published>2021-12-29T01:23:05.000Z</published>
    <updated>2023-05-19T01:32:06.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天我在Quora上看到的一个人，询问程序员如何编写包含10,000多行代码以上的项目。当软件变大时，维护起来就更困难了，这是事实。所以这就是事情 – 如果你不保持你的项目井然有序，你将很难跟上节奏。稍后，您会发现自己把更多的时间浪费在处理混乱的项目，而不是添加新功能。任何Unity项目都是这样。以下是（在我看来）比较重要的建议，可以帮助保持项目的有序性。</p><h2 id="资源目录结构"><a href="#资源目录结构" class="headerlink" title="资源目录结构"></a>资源目录结构</h2><p>如果不提及组织项目目录结构，我们就不能谈论组织。Unity在这方面给你一个完全的自由，但正因为如此，它经常变得非常混乱。这是我个人使用的目录结构：</p><ul><li>3rd-Party</li><li>Animations</li><li>Audio</li><li>Music</li><li>SFX</li><li>Materials</li><li>Models</li><li>Plugins</li><li>Prefabs</li><li>Resources</li><li>Textures</li><li>Sandbox</li><li>Scenes</li><li>Levels</li><li>Other</li><li>Scripts</li><li>Editor</li><li>Shaders</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>不要将任何资源存放在根目录中。尽可能使用子目录。</li><li>除非确实需要，否则不要在根目录中创建任何其他目录。</li><li>与命名保持一致。如果您决定将camel case用于目录名称和低字母用于资产，请坚持使用该约定。</li><li>不要尝试将特定于上下文的资源移动到常规目录。例如，如果从模型生成材质，请不要将它们移动到Materials目录，因为稍后您将不知道它们来自何处。</li><li>使用第三方存储从资源商店导入的资源。它们通常有自己的结构，不应该改变。</li><li>使用Sandbox 目录进行您不完全确定的任何实验。在处理这类事情时，你最不想要关心的是一个合适的组织。执行您想要的操作，然后在确定要将其包含在项目中时将其删除或整理。当您与其他人一起处理项目时，请创建您的个人Sandbox子目录，如： Sandbox &#x2F; JohnyC。</li></ul><h2 id="场景层次结构"><a href="#场景层次结构" class="headerlink" title="场景层次结构"></a>场景层次结构</h2><p>在项目的层次结构旁边还有场景层次结构。和以前一样，我会给你一个模板。您可以根据自己的需要进行调整。</p><ul><li>Management</li><li>GUI</li><li>Cameras</li><li>Lights</li><li>World</li><li>Terrain</li><li>Props</li><li>_Dynamic</li></ul><h3 id="几条原则："><a href="#几条原则：" class="headerlink" title="几条原则："></a>几条原则：</h3><ul><li>所有的空物体应保持在 <code>Vector3.zero</code>，默认旋转角度和缩放比例。</li><li>当您在运行时实例化(克隆) 对象时，请确保将其放在 _Dynamic 中 – 不要污染层次结构的根目录，否则您将发现难以浏览它。</li><li>对于仅作为脚本容器的空对象，请使用“@”作为前缀 – 例如@Cheats。</li></ul><h2 id="为所有物体设置预制体（Prefab）"><a href="#为所有物体设置预制体（Prefab）" class="headerlink" title="为所有物体设置预制体（Prefab）"></a>为所有物体设置预制体（Prefab）</h2><p>Unity中的预制体并不完美，但它们是您分享预先配置的对象层次结构的最佳选择。一般来说，尝试设置你放在场景上的所有东西为预制体。只需向其中添加一个或多个预制体，您就可以从空场景中创建新关卡。<br>您应该使用预制体的原因是，当预制体更改时，所有实例也会更改。有100个级别，并希望在所有这些级别上添加相机效果？不是问题！如果您的相机是预制体，只需将相机效果添加到相机预制体即可！<br>请注意，您不能在另一个预制件中安装预制体。改为使用链接 – 有一个需要分配预制体的字段，并确保在创建实例时分配它。当有意义时，请考虑在 <code>Awake()</code> 或 <code>OnEnable()</code> 中自动连接预制实例。</p><h2 id="了解如何使用版本控制系统（VCS）"><a href="#了解如何使用版本控制系统（VCS）" class="headerlink" title="了解如何使用版本控制系统（VCS）"></a>了解如何使用版本控制系统（VCS）</h2><p>您可能已经了解了有关GIT，Subversion或任何其他VCS的信息。事实上，“了解某事”只是你可能学到的一小部分。您应该专注于了解您选择的重要但不经常使用的VCS功能。为什么？主要是因为VCS系统比您想象的要强大得多，不幸的是，许多用户使用它们只不过是备份和同步解决方案。例如，您是否知道GIT允许您存储更改，因此您可以在以后处理它们而无需向主分支提交任何内容？</p><p>程序员倾向于在以后需要时注释掉代码块。不要那样做！如果您正在使用VCS，请了解如何快速浏览文件的先前版本。熟悉它时，如果没有不必要的注释代码块，代码看起来会更好。</p><p>这里有一个很好的GIT用户提示资源：<a href="http://gitready.com/">http://gitready.com</a></p><h2 id="学习编写编辑器脚本"><a href="#学习编写编辑器脚本" class="headerlink" title="学习编写编辑器脚本"></a>学习编写编辑器脚本</h2><p>Unity在可扩展性方面是一个很棒的游戏引擎（参见Assets Store）。学习如何编写编辑器脚本并利用这些知识。您没有必要为脚本创建精美的GUI，它可以是简单的事情，因为菜单条目正在做一些有用的事情。以下是我不久前创建的编辑器脚本的一些示例：</p><p>例如：</p><ul><li>Google表格.csv下载 – 我在Google云端硬盘上保存了一个翻译电子表格。它自动将最新版本下载为.csv文件，因此我从未必须手动完成。</li><li>随机化树的位置，旋转和大小 – 我有很多树，并希望它看起来更像森林而不是网格。</li><li>创建分发 – 为指定目标构建，压缩所有文件并复制到正确的位置。</li><li>源代码中的字符串替换 – 我有几个包含应用程序版本的文件。</li></ul><p>您可以从官方文档中学习如何创建编辑器脚本。</p><h2 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h2><p>你听说过防御性编程吗？维基百科将其定义如下：</p><p>防御性编程是一种防御性设计，旨在确保在不可预见的情况下软件的持续功能。特别是当一个软件被滥用时，使用防御性编程技术。<br>通常，当您编写MonoBehaviours时，您应该确保：</p><p>设置所有需要的引用<br>存在所有必需的组件<br>如果您使用单身，请确保它们存在<br>如果您正在搜索对象并期望找到某些内容，请尽快进行<br>混合编辑器代码（<code>ExecuteInEditMode</code> 和 <code>#if UNITY_EDITOR</code>）在运行场景之前进行尽可能多的检查<br>对于其中许多检查，您可以使用断言。</p><h2 id="添加作弊器"><a href="#添加作弊器" class="headerlink" title="添加作弊器"></a>添加作弊器</h2><p>在学习如何编写编辑器脚本之后，您应该能够编写一组编辑器内作弊。它可以作为解锁某些内容的菜单条目（例如所有级别）。它很容易创建：</p><p>一般来说，你应该写作弊，让你：</p><ul><li>解锁所有关卡，角色，物品等</li><li>让你无敌</li><li>修改时间，金钱，硬币等值</li><li>可以看到玩家不应该看到的东西</li><li>还有其他任何可以帮助您测试游戏的东西</li><li>当然更实际（但更难写）是游戏中的作弊。这些类型的作弊可以在Unity编辑器外部执行，但这部分显示更加必要。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前几天我在Quora上看到的一个人，询问程序员如何编写包含10,000多行代码以上的项目。当软件变大时，维护起来就更困难了，这是事实。所以这就是事情 – 如果你不保持你的项目井然有序，你将很难跟上节奏。稍后，您会发现自己把更多的时间浪费在处理混乱的项目，而不是添加新功能。任何Unity项目都是这样。以下是（在我看来）比较重要的建议，可以帮助保持项目的有序性。&lt;/p&gt;
&lt;h2 id=&quot;资源目录结构&quot;&gt;&lt;a href=&quot;#资源目录结构&quot; class=&quot;headerlink&quot; title=&quot;资源目录结构&quot;&gt;&lt;/a&gt;资源目录结构&lt;/h2&gt;&lt;p&gt;如果不提及组织项目目录结构，我们就不能谈论组织。Unity在这方面给你一个完全的自由，但正因为如此，它经常变得非常混乱。这是我个人使用的目录结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3rd-Party&lt;/li&gt;
&lt;li&gt;Animations&lt;/li&gt;
&lt;li&gt;Audio&lt;/li&gt;
&lt;li&gt;Music&lt;/li&gt;
&lt;li&gt;SFX&lt;/li&gt;
&lt;li&gt;Materials&lt;/li&gt;
&lt;li&gt;Models&lt;/li&gt;
&lt;li&gt;Plugins&lt;/li&gt;
&lt;li&gt;Prefabs&lt;/li&gt;
&lt;li&gt;Resources&lt;/li&gt;
&lt;li&gt;Textures&lt;/li&gt;
&lt;li&gt;Sandbox&lt;/li&gt;
&lt;li&gt;Scenes&lt;/li&gt;
&lt;li&gt;Levels&lt;/li&gt;
&lt;li&gt;Other&lt;/li&gt;
&lt;li&gt;Scripts&lt;/li&gt;
&lt;li&gt;Editor&lt;/li&gt;
&lt;li&gt;Shaders&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;注意：&quot;&gt;&lt;a href=&quot;#注意：&quot; class=&quot;headerlink&quot; title=&quot;注意：&quot;&gt;&lt;/a&gt;注意：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不要将任何资源存放在根目录中。尽可能使用子目录。&lt;/li&gt;
&lt;li&gt;除非确实需要，否则不要在根目录中创建任何其他目录。&lt;/li&gt;
&lt;li&gt;与命名保持一致。如果您决定将camel case用于目录名称和低字母用于资产，请坚持使用该约定。&lt;/li&gt;
&lt;li&gt;不要尝试将特定于上下文的资源移动到常规目录。例如，如果从模型生成材质，请不要将它们移动到Materials目录，因为稍后您将不知道它们来自何处。&lt;/li&gt;
&lt;li&gt;使用第三方存储从资源商店导入的资源。它们通常有自己的结构，不应该改变。&lt;/li&gt;
&lt;li&gt;使用Sandbox 目录进行您不完全确定的任何实验。在处理这类事情时，你最不想要关心的是一个合适的组织。执行您想要的操作，然后在确定要将其包含在项目中时将其删除或整理。当您与其他人一起处理项目时，请创建您的个人Sandbox子目录，如： Sandbox &amp;#x2F; JohnyC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;场景层次结构&quot;&gt;&lt;a href=&quot;#场景层次结构&quot; class=&quot;headerlink&quot; title=&quot;场景层次结构&quot;&gt;&lt;/a&gt;场景层次结构&lt;/h2&gt;&lt;p&gt;在项目的层次结构旁边还有场景层次结构。和以前一样，我会给你一个模板。您可以根据自己的需要进行调整。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Management&lt;/li&gt;
&lt;li&gt;GUI&lt;/li&gt;
&lt;li&gt;Cameras&lt;/li&gt;
&lt;li&gt;Lights&lt;/li&gt;
&lt;li&gt;World&lt;/li&gt;
&lt;li&gt;Terrain&lt;/li&gt;
&lt;li&gt;Props&lt;/li&gt;
&lt;li&gt;_Dynamic&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Unity" scheme="http://huozk.cn/categories/Unity/"/>
    
    
    <category term="unity-project" scheme="http://huozk.cn/tags/unity-project/"/>
    
  </entry>
  
  <entry>
    <title>你好 Hexo</title>
    <link href="http://huozk.cn/2021/12/hello-world/"/>
    <id>http://huozk.cn/2021/12/hello-world/</id>
    <published>2021-12-29T00:01:05.000Z</published>
    <updated>2023-05-19T02:02:49.719Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">this is first blog about hexo.</summary>
    
    
    
    
  </entry>
  
</feed>
